<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <!-- JQuery (used for bootstrap and jekyll search) -->
    <script src="/assets/js/jquery-3.2.1.min.js" ></script>
    
    <!-- Main JS (navbar.js and katex_init.js)-->
    <script defer=true src="/assets/js/main.min.js"></script>
    
    <!-- CSS -->
    <link rel="stylesheet" href="/assets/css/main.css">

    <!--Favicon-->
    <link rel="shortcut icon" href="/assets/favicon.ico" type="image/x-icon">

    <!-- Canonical -->
    <link rel="canonical" href="http://localhost:4000/search/">

    <!-- RSS -->
    <link rel="alternate" type="application/atom+xml" title="Signal" href="http://localhost:4000///feed.xml"/>

    <!-- Font Awesome -->
    <!-- <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet"> -->
    <link rel="stylesheet" type="text/css" href="/assets/css/font-awesome.min.css">

    <!-- Google Fonts -->
    
    <link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700,700italic,400italic" rel="stylesheet" type="text/css"> 
    

    <!-- KaTeX 0.8.3 -->
    
    <!--<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/KaTeX/0.8.3/katex.min.css">
    <script src="//cdnjs.cloudflare.com/ajax/libs/KaTeX/0.8.3/katex.min.js"></script> -->
    <link rel="stylesheet" type="text/css" href="/assets/css/katex.min.css">
    <script src="/assets/js/katex.min.js">
    </script>
    

    <!-- Google Analytics -->
    
    
    <!-- seo tags -->
    <!-- Begin Jekyll SEO tag v2.4.0 -->
<title>Search | Signal</title>
<meta name="generator" content="Jekyll v3.8.0" />
<meta property="og:title" content="Search" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="A website with blog posts" />
<meta property="og:description" content="A website with blog posts" />
<link rel="canonical" href="http://localhost:4000/search/" />
<meta property="og:url" content="http://localhost:4000/search/" />
<meta property="og:site_name" content="Signal" />
<script type="application/ld+json">
{"url":"http://localhost:4000/search/","headline":"Search","description":"A website with blog posts","@type":"WebPage","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <!-- Manual seo tags -->
    <!--
    <title>Search | Signal</title>
    <meta name="description" content="">
    -->
</head>

  <body>
    <header class="site-header">
    
    <!-- Logo and title -->
	<div class="branding">
		<a href="/">
			<img class="avatar" src="/assets/img/triangle.svg" alt=""/>
		</a>

		<h1 class="site-title">
			<a href="/">Signal</a>
		</h1>
	</div>
    
    <!-- Toggle menu -->
    <nav class="clear">
    <a id="pull" class="toggle" href="#">
    <i class="fa fa-bars fa-lg"></i>
    </a>
    
    <!-- Menu -->
    <ul>
        
        
        
        
        <li class="separator">
            |
        </li>
        <li>
            <a class="clear" href="/about/">
                About
            </a>
        </li>
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
         
        
        <li class="separator">
            |
        </li>
        <li>
            <a class="clear" href="http://localhost:4000/portfolio">
                Portfolio
            </a>
        </li>
        
        
        <li class="separator">
            |
        </li>
        <li>
            <a class="clear" href="http://localhost:4000/search">
                <i class="fa fa-search" aria-hidden="true"></i>
            </a>
        </li>
        
        
        <li class="separator">
            |
        </li>
        <li>
            <a class="clear" href="http://localhost:4000/tags">
                <i class="fa fa-tags" aria-hidden="true"></i>
            </a>
        </li>
        
        
    </ul>
        
	</nav>
</header>

    <div class="content">
      <article class="feature-image">
  <header id="main" style="background-image: url('/assets/img/pexels/search-map.jpeg')">
    <h1 id="Search" class="title">
        Search
    </h1>
    
    
    <h2 class="subtitle">What are you looking for?</h2>
    
      
  </header>
  <section class="post-content"><!-- Html Elements for Search -->
<input type="text" id="search-input" placeholder="Enter keywords..." class="search-bar">
<br>
<br>
<ul id="results-container"></ul>

<section>
    <!-- Script pointing to jekyll-search.js -->
    <script src="/assets/js/simple-jekyll-search.min.js" type="text/javascript"></script>

    <script type="text/javascript">
        SimpleJekyllSearch({
            searchInput: document.getElementById('search-input'),
            resultsContainer: document.getElementById('results-container'),
            json: [
                    
                     
                        {
                          "title"    : "[python] 리스트 변수를 반복문 돌리기 예시",
                          "category" : "",
                          "tags"     : " programming, python",
                          "url"      : "/programming/2018/04/10/python_for_loop.html",
                          "date"     : "April 10, 2018",
                          "excerpt"  : "students = []student1_info = {    &quot;first_name&quot;: &quot;Martin&quot;,    &quot;las_name&quot; : &quot;Lawrence&quot;,    &quot;student_no&quot;: 9854}student2_info = {    &quot;first_name&quot;: &quot;Robert&quot;,    &quot;las_name&quot; ...",
                          "content"  : "students = []student1_info = {    &quot;first_name&quot;: &quot;Martin&quot;,    &quot;las_name&quot; : &quot;Lawrence&quot;,    &quot;student_no&quot;: 9854}student2_info = {    &quot;first_name&quot;: &quot;Robert&quot;,    &quot;las_name&quot; : &quot;Gant&quot;,    &quot;student_no&quot;: 6790}student3_info = {    &quot;first_name&quot;: &quot;George&quot;,    &quot;las_name&quot; : &quot;Murphy&quot;,    &quot;student_no&quot;: 4728}for i in range(1, 4):    students.append(eval(&#39;student%d_info&#39;% (i)))print(students)      eval() : 실행 가능한 문자열을 입력 받아 실행한 결과값을 리턴하는 함수이다.    &amp;gt;&amp;gt;&amp;gt; eval(&#39;1+2&#39;)3&amp;gt;&amp;gt;&amp;gt; eval(&quot;&#39;hi&#39; + &#39;a&#39;&quot;)&#39;hia&#39;&amp;gt;&amp;gt;&amp;gt; eval(&#39;divmod(4, 3)&#39;)(1, 1)        ​        append() : 객체를 맨 뒤에 추가해주는 함수이다.    &amp;gt;&amp;gt;&amp;gt; x = [1, 2, 3]&amp;gt;&amp;gt;&amp;gt; x.append([4, 5, 6])&amp;gt;&amp;gt;&amp;gt; print (x)[1, 2, 3, [4, 5, 6]]        ​        extend() : 여러개의 값을 확장시킬 수 있는 함수이다. 함수로 전달되는 인수에는 리스트만 올 수 있다.    &amp;gt;&amp;gt;&amp;gt; x = [1, 2, 3]  &amp;gt;&amp;gt;&amp;gt; x.extend([4, 5, 6])  &amp;gt;&amp;gt;&amp;gt; print (x)  [1, 2, 3, 4, 5, 6]​"
                        } ,
                     
                        {
                          "title"    : "[Algorithms] 807.Max Increase to Keep City Skyline",
                          "category" : "",
                          "tags"     : " algorithms",
                          "url"      : "/algorithms/2018/04/09/LeetCode_807.html",
                          "date"     : "April 9, 2018",
                          "excerpt"  : "807.Max Increase to Keep City Skyline문제  In a 2 dimensional array grid, each value grid[i][j] represents the height of a building located there.  2차원 배열 그리드(grid)에서, 각각의 grid[i][j] 값은 그곳에 위치한 건물의 높이를 나타낸다.  We are allowed to increase the height of...",
                          "content"  : "807.Max Increase to Keep City Skyline문제  In a 2 dimensional array grid, each value grid[i][j] represents the height of a building located there.  2차원 배열 그리드(grid)에서, 각각의 grid[i][j] 값은 그곳에 위치한 건물의 높이를 나타낸다.  We are allowed to increase the height of any number of buildings, by any amount (the amounts can be different for different buildings). Height 0 is considered to be a building as well.  우리는 임의의 수의 건물 높이를 어느정도 증가시킬 수 있다(정도는 건물마다 다를 수 있다). 일반적으로 높이가 0인 건물도 건물이다.  At the end, the “skyline” when viewed from all four directions of the grid, i.e. top, bottom, left, and right, must be the same as the skyline of the original grid. A city’s skyline is the outer contour of the rectangles formed by all the buildings when viewed from a distance. See the following example.  마지막으로, 그리드의 4 가지 방향 (위, 아래, 왼쪽, 오른쪽)에서 보았을 때의 “스카이 라인”은 원래 그리드의 스카이 라인과 동일해야한다. 도시의 스카이 라인은 거리를 두고 볼 때 모든 건물에 의해 형성되는 사각형의 외곽선이다. 다음 예를 참조하라.  What is the maximum total sum that the height of the buildings can be increased?  건물의 높이를 올릴 수있는 최대 합계는 얼마인가?  Example:Input: grid = [[3,0,8,4],[2,4,5,7],[9,2,6,3],[0,3,1,0]]Output: 35Explanation: The grid is:[ [3, 0, 8, 4],   [2, 4, 5, 7],  [9, 2, 6, 3],  [0, 3, 1, 0] ]The skyline viewed from top or bottom is: [9, 4, 8, 7]The skyline viewed from left or right is: [8, 7, 9, 3]The grid after increasing the height of buildings without affecting skylines is:gridNew = [ [8, 4, 8, 7],            [7, 4, 7, 7],            [9, 4, 8, 7],            [3, 3, 3, 3] ]    Notes:      1 &amp;lt; grid.length = grid[0].length &amp;lt;= 50.    All heights grid[i][j] are in the range [0, 100].    All buildings in grid[i][j] occupy the entire grid cell: that is, they are a 1 x 1 x grid[i][j] rectangular prism.  접근주어진 Example을 그림으로 그려서 문제를 파악해보았다.2차원 배열이 Example과 같이 주어져 있을 때, 위, 아래, 왼쪽, 오른쪽에서 살펴 본 후 가장 큰 값이 스카이라인이다. 즉, 노란화살표는 열(column) 기준으로 바라봤을 때 최댓값이고, 파란 화살표는 행(row) 기준으로 봤을 때 최댓값인 것이다.아래 그림을 참고하여 열 기준으로 최댓값을 찾아보면 1열은 9, 2열은 4, 3열은 8, 4열은 7이 된다. 행을 기준으로 최댓값을 찾아보면 1행은 8, 2행은 7, 3행은 9, 4행은 3이다.다음은 스카이 라인에 영향을 미치지 않고 건물 높이를 증가시킨 후의 그리드를 찾는다. 찾는 방법을 생각해보면 먼저 기준되는 값에서 행과 열을 살펴봤을 때 앞서 구한 행과 열의 max값 중 자기 자신보다는 크고 max값 중 작은 값까지 스카이라인을 올릴 수 있다.아래 그림을 살펴보면, 3을 기준으로 했을 때 행에는 8, 열에는 9가 스카이라인이다. 8과 9 중 작은 값까지는 스카이라인을 올릴 수 있다. 그렇게 해야 열에서 봤을 때, 행에서 봤을 때 모두 기존의 스카이라인을 넘어서지 않기 때문이다.알고리즘 짜기알고리즘을 세분화 시켜보면 주어진 2차원 array를 2차원 matrix 처럼 생각했을 때,      각 행의 최댓값을 구한다. row_max(각각의 행)        각 열의 최댓값을 구한다. col_max(각각의 열)        각 원소를 돌면서 해당 원소의 값, 행의 최댓값, 열의 최댓값 중 중앙값까지 값을 올린다. median(해당원소, 행의 최댓값, 열의 최댓값)        증가시킬 수 있는 최대 합계를 구하기 위해 새로 구한 그리드의 합에서 처음 주어진 그리드의 합을 뺀다.    sum(새로 증가시킨 그리드) - sum(처음 그리드 값)  코드 작성 (작성 중….)class Solution(object):    def Skyline(self, grid):        # row_max        row_max = []        for i in grid:            row_max.append(max(i))        # transpose 2d array        tr = [list(i) for i in zip(*grid)]        # col_max        col_max = []        for j in tr:            col_max.append(max(j))        print(&quot;row max : &quot;, row_max, &quot;\n&quot;, &quot;col max : &quot;, col_max)시간복잡도(작성 중…)"
                        } ,
                     
                        {
                          "title"    : "[Programming] Python에서 CSV 파일을 읽어들이는 여러가지 방법",
                          "category" : "",
                          "tags"     : " programming, python",
                          "url"      : "/programming/2018/04/02/Python_CSV.html",
                          "date"     : "April 2, 2018",
                          "excerpt"  : "방법1. 기본 내장함수 사용1. csv.readerimport csvdat = open(&#39;file.csv&#39;)reader = csv.reader(dat)lines = list(reader)2. 한 줄씩 읽어들여서 리스트로 만들기import csvdat1_list = []dat2_list = []with open(&#39;file.csv&#39;, &#39;r&#39;) as raw:    reader = csv.reader(r...",
                          "content"  : "방법1. 기본 내장함수 사용1. csv.readerimport csvdat = open(&#39;file.csv&#39;)reader = csv.reader(dat)lines = list(reader)2. 한 줄씩 읽어들여서 리스트로 만들기import csvdat1_list = []dat2_list = []with open(&#39;file.csv&#39;, &#39;r&#39;) as raw:    reader = csv.reader(raw)    for lines in reader:        print(lines)        dat1_list.append(lines)        start = len(dat2_list)        dat2_list[start:start] = lines3. from_csvdat.from_csv(&#39;file.csv&#39;,          sep = &#39;,&#39;,          encoding = &#39;utf-8&#39;)dat.head()4. readlines()open(&#39;file.csv&#39;).readlines()    # 파일을 한 줄씩 전체를 읽어들여서 리스트로 반환방법2. Pandas 사용import pandas as pddat = pd.read_csv(&#39;file.csv&#39;,                   thousands = &#39;,&#39;,                  index_col = 0,                  names = [&#39;col1&#39;, &#39;col2&#39;, &#39;col3&#39;],                  encoding = &#39;utf-8&#39;)dat.head()dat.columns    # 열 이름 출력dat.rename(columns = {dat.columns[0] : &#39;명칭&#39;}, inplace = True )    # 열 이름 변경"
                        } ,
                     
                        {
                          "title"    : "[Python] Python Class note",
                          "category" : "",
                          "tags"     : " python, programming",
                          "url"      : "/programming/2018/03/26/python_classnote.html",
                          "date"     : "March 26, 2018",
                          "excerpt"  : "  Inflearn의 &amp;lt;프로그래밍, 데이터 과학을 위한 파이썬 입문&amp;gt; 강의를 정리한 강의노트 일부.  강의는 https://www.inflearn.com/course/python-%ED%8C%8C%EC%9D%B4%EC%8D%AC-%EC%9E%85%EB%AC%B8-%EA%B0%95%EC%A2%8C/ 에서 수강 가능.Chapter 5. FunctionFunction Concept 1Function 함수어떤 일을 수행하...",
                          "content"  : "  Inflearn의 &amp;lt;프로그래밍, 데이터 과학을 위한 파이썬 입문&amp;gt; 강의를 정리한 강의노트 일부.  강의는 https://www.inflearn.com/course/python-%ED%8C%8C%EC%9D%B4%EC%8D%AC-%EC%9E%85%EB%AC%B8-%EA%B0%95%EC%A2%8C/ 에서 수강 가능.Chapter 5. FunctionFunction Concept 1Function 함수어떤 일을 수행하는 코드 덩어리      반복적인 수행을 회만 작성 후 호출        코드를 논리적인 단위로 분리        캡슐화 : 인터페이스만 알면 타인의 코드 사용  함수 선언 문법함수 이름, parameter, return value(optional)def calculate_rectangle_area(x, y):  return x * yrectangle_x = 10rectangle_y = 20print(&quot;사각형 x의 길이: &quot;, rectangle_x)print(&quot;사각형 y의 길이: &quot;, rectangle_y)# 넓이를 구하는 함수 호출print(&quot;사각형의 넓이: &quot;, calculate_rectangle_area(rectangle_x, rectangle_y))Parameter vs. ArgumentPrarmeter : 함수의 입력 값 인터페이스def f(x):  return 2 * x + 7Argument : Parameter에 실제 대입되는 값print(f(2))함수 형태Parameter 유무, return value 유무에 따라 함수의 형태가 다름def aRectangleArea():       # 인자 x, 리턴 값 x  print(5 * 7)35 출력 후 함수는 none이 됨print(aRectangleArea()) 하면 none 출력(예)list_test = [5,4,3,2,1]print(list_test.sort())None 출력 됨. 왜냐하면 sort()는 return값이 없는 함수이므로.  sort(), sorted() 차이list_test.sort()는 반환 값이 없고, list_test 자체에서 순서 정렬sorted(list_test)는 메모리 다른 곳에 복사 해서 정렬. 즉, list_test 원본은 변화 없음.def bRectangleArea(x, y):   # 인자 o, 리턴 값 x  print(x * y)  def cRectangleArea():       # 인자 x, 리턴 값 o  return(5 * 7)def dRectangleArea(x, y):   # 인자 o, 리턴 값 o  return(x * y)Function Concept 2함수 호출 방식함수의 인자를 전달하는 방식  Call by Value 값에 의한 호출함수에 인자를 넘길 때 값만 넘김함수 내에 인자 값 변경 시, 호출자에게 영향을 주지 않음.  Call by Reference 참조에 의한 호출함수에 인자를 넘길 때 메모리 주소를 넘김.함수 내에 인자 값 변경 시, 호출자의 값도 변경 됨.파이썬 함수 호출 방식파이썬은 객체의 주소가 함수로 전달되는 방식전달된 객체를 참조하여 변경 시 호출자에게 영향을 주지만, 새로운 객체를 만들 경우 호출자에게 영향을 주지 않음.def spam(eggs):  eggs.append(1) # 기존 객체의 주소값에 [1] 추가  eggs = [2, 3]  # 새로운 객체 생성  ham = [0]spam(ham)print(ham)   # [0, 1]변수의 범위 (Scoping Rule)변수가 사용되는 범위(함수 또는 메인 프로그램)  Local Variable  Global Variable : 함수 내 전역변수 사용 시 global 키워드 사용전역변수는 함수에서 사용 가능. 하지만 함수 내에 전역 변수와 같은 이름의 변수를 선언하면 새로운 지역 변수가 생성 됨.def calculate(x, y):  total = x + y  print(&quot;In Function&quot;)  print(&quot;a: &quot;, str(a), &quot;b:&quot;, str(b), &quot;a+b: &quot; str(a+b), &quot;total: &quot;, str(total))  return totala = 5        # a, b는 전역변수b = 7total = 0    # 전역변수 totalprint(&quot;In Program - 1&quot;)print(&quot;a: &quot;, str(a), &quot;b:&quot;, str(b), &quot;a+b: &quot; str(a+b))sum = calculate(a, b)print(&quot;After Calculation&quot;)print(&quot;Total : &quot;, str(total), &quot;Sum:&quot;, str(sum)) # 지역변수는 전역변수에 영향xSwap함수를 통해 변수 간 값을 교환하는 함수Call by XXXX를 설명하기 위한 전통적인 함수 예시a = [1, 2, 3, 4, 5] 일 때 아래 함수 중 실제 swap이 일어나는 함수는?def swap_value(x, y):  temp = x  x = y  y = temp    def swap_offset(offset_x, offset_y):  temp = a[offset_x]  a[offset_x] = a[offset_y]  a[offset_y] = temp  def swap_reference(list, offset_x, offset_y):  temp = list[offset_x]  list[offset_x] = list[offset_y]  list[offset_y] = tempswap_offset : a 리스트의 전역 변수 값을 직접 변경swap_reference : a 리스트 객체의 주소 값을 받아 값을 변경a = [1, 2, 3, 4, 5]swap_value(a[1], a[2])print(a)     # [1, 2, 3, 4, 5]swap_offset(1, 2)print(a)     # [1, 3, 2, 4, 5]swap_reference(a, 1, 2)print(a)     # [1, 3, 2, 4, 5]재귀함수 Recursive Function자기 자신을 호출하는 함수점화식과 같은 재귀적 수학 모형을 표현할 때 사용재귀 종료 조건 존재, 종료 조건까지 함수 호출 반복def factorial(n):  if n == 1 :     return 1  else:    return n * factorial(n-1)print(factorial)Function argumentsPassing arguments  함수에 입력되는 arguments는 다양한 형태를 가짐1) Keyword arguments2) Default arguments3) Variable-length asterisk (가변인자)Keyword arguments함수에 입력되는 parameter의 변수명을 사용, arguments를 넘김.def print_something(my_name, your_name):  print(&quot;Hello {o}, My name is {1}&quot;.format(your_name, my_name))  print_something(&quot;Jane&quot;, &quot;John&quot;)print_something(your_name = &quot;Jane&quot;, my_name = &quot;John&quot;)Default argumentsparameter의 기본 값을 사용, 입력하지 않을 경우 기본값 출력def print_something(my_name, your_name=&quot;John&quot;):  print(&quot;Hello {o}, My name is {1}&quot;.format(your_name, my_name))  print_something(&quot;Jane&quot;, &quot;John&quot;)print_something(&quot;Jane&quot;)Variable-length asterisk함수의 parameter가 정해지지 않은 상태. 다항 방정식, 마트 물건 계산 함수 등..가변인자 using Asterisk  갯수가 정해지지 않은 변수를 함수의 parameter로 사용하는 법  keyword arguments와 함께, argument 추가가 가능  Asterisk(*) 기호를 사용하여 함수의 parameter를 표시함  입력된 값은 tuple type으로 사용할 수 있음  가변인자는 오직 한 개만 맨 마지막 parameter 위치에 사용 가능사용가변인자는 일반적으로 *args를 변수명으로 사용기존 parameter 이후에 나오는 값을 tuple로 저장def asterisk_test(a, b, *args):  return a + b + sum(args)print(asterisk_test(1, 2, 3, 4, 5))def asterisk_test2(*args):  x, y, *z = args       # unpacking  print(x)  return x, y, zprint(asterisk_test2(3,4,5,10,11,12))Keyword variable-length 키워드 가변인자Parameter 이름을 따로 지정하지 않고 입력하는 방법Asterisk(*) 두 개를 사용하여 함수의 parameter를 표시 : **kwargs입력된 값은 dict type으로 사용할 수 있음가변인자는 오직 한 개만 기존 가변인자 다음에 사용def kwargs_test1(**kwargs):  print(kwargs)kwargs_test1(first = 3, second = 4, third = 5)# {&#39;second&#39;:4, &#39;third&#39;:5, &#39;first&#39;:3}  으로 출력 됨. 순서 상관 없음.def kwargs_test2(**kwargs):  print(&quot;First value is {first}&quot;.format(**kwargs))  print(&quot;Second value is {second}&quot;.format(**kwargs))  print(&quot;Third value is {third}&quot;.format(**kwargs))  kwargs_test2(first=3, second=4, third=5)Cording Convention and FunctionPEP8 - 파이썬 코딩 컨벤션의 기준들여쓰기 공백 4칸한줄은 최대 79자연산자는 1칸 이상 안 띄움불필요한 주석 삭제소문자 i, 대문자 O, 대문자 I 금지flake8 모듈로 체크 : conda install flake8Chapter 6. String문자열 String시퀀스 자료형으로 문자형 data를 메모리에 저장.영문자 한 글자는 1byte의 메모리 공간을 사용.&amp;gt;&amp;gt;&amp;gt; import sys    # sys 모듈 호출&amp;gt;&amp;gt;&amp;gt; print(sys.getsizeof(&quot;a&quot;)	# a의 메모리 사이즈 출력1 byte의 메모리 공간이진수 한 자릿수는 1 bit. 0 or 11 byte = 8 bit = 2^8 = 256 까지 저장 가능문자열 특징인덱싱 Indexingsequence = list문자열의 각 문자는 개별 주소(offset)를 가짐이 주소를 사용해 할당된 값을 가져오는 것이 인덱싱List와 같은 형태로 데이터를 처리a = &quot;abcde&quot;print(a[0], a[4])	# a eprint(a[-1], a[5])	# e a문자열 함수문자열 함수 예제title = &quot;TEAMLAB X Inflearn&quot;title.upper()title.split(&quot; &quot;)title.isdigit()title.count(&quot;a&quot;)title.upper().count(&quot;a&quot;)다양한 문자열 표현문자열 선언은 큰따옴표 또는 작은 따옴표It’s OK는 어떻게 표현할까?1) a = ‘lt&#39; ok.’2) a = “It’s ok.” #두줄 이상은 어떻게 저장할까?1) \n2) 큰따옴표 또는 작은 따옴표 3개특수문자문자열을 표시할 때 백슬래시 \ 를 사용하여 키보드로 표시하기 어려운 문자 표현Lab : Yesterday Counter StringBeatles의 노래 Yesterday에 Yesterday라는 말이 몇 번 나올까?wget https://raw.githubusercontent.com/TeamLab/cs50_example_code/master/12_string/yesterday.txt# 데이터 읽어들이기  f = open(&quot;yesterday.txt&quot;, &#39;r&#39;)yesterday_lyric = &quot;&quot;while 1:  line = f.readline()  if not line:    break  yesterday_lyric = yesterday_lyric + line.strip() + &quot;\n&quot;f.close()# Yesterday Counter Stringn_of_yesterday = yesterday_lyric.upper().count(&quot;YESTERDAY&quot;)print(&quot;Number of a Word &#39;Yesterday&#39;&quot;, n_of_yesterday)Lab : Yesterday Counter 2대소문자를 구분하여 “Yesterday”와 “yesterday”의 갯수를 나누어서 세는 프로그램을 작성하세요.n_title_of_yesterday = yesterday_lyric.count(&quot;Yesterday&quot;)n_lower_of_yesterday = yesterday_lyric.count(&quot;yesterday&quot;)Chapter 7. Data Structure데이터 구조  스택, 큐 (stack &amp;amp; queue)  튜플, 집합 (tuple &amp;amp; set)  사전 (Dictionary)Stack &amp;amp; QueueStack      나중에 넣은 데이터를 먼저 반환하도록 설계된 메모리 구조로 Last In First Out(LIFO)로 구현 됨        Data의 입력을 Push, 출력을 Pop이라고 함  Stack in python      파이썬은 리스트를 사용하여 스택 구조를 활용        push를 append(), pop을 pop() 사용  a = [1, 2, 3, 4, 5]a.append(10)a.append(20)a.pop()		# 20 출력a.pop()		# 10 출력Stack Example스택 구조를 활용, 입력된 글자를 역순으로 출력word = input(&quot;Input a word : &quot;)word_list = list(word)	# String to Listprint(word_list)  # [&#39;H&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;]  : 입력값이 Hello일 경우 한 글자씩 리스트 생성result = []for _ in range(len(word_list)):		# _ : 사용하지 않는 것 표시  result.append(word_list.pop())	# 하나씩 빼면서 출력print(word[::-1])Queue  먼저 넣은 데이터를 먼저 반환하도록 설계된 메모리 구조로 First In First Out으로 구현 됨  Stack과 반대되는 개념Que in python파이썬은 리스트를 사용하여 큐 구조를 활용put은 append(), get은 pop(0)를 사용a = [1, 2, 3, 4, 5]a.append(10)a.append(20)a.pop(0)	# 1 출력a.pop(0)	# 2 출력Tuple &amp;amp; SetTuple  값의 변경이 불가능한 리스트  선언시 “( )”를 사용  리스트의 연산, 인덱싱, 슬라이싱 등을 동일하게 사용t = (1, 2, 3)print(t + t, t * 2)    # (1,2,3,1,2,3)(1,2,3,1,2,3)t[1] = 5    # errort = (1)    # 일반정수로 1로 인식t = (1, )  # 값이 하나인 Tuple은 반드시 &quot;,&quot;를 붙여야 함 (1,)왜 쓸까?프로그램을 작동하는 동안 변경되지 않은 데이터의 저장 (ex) 학번, 이름, 우편번호 등Set  값을 순서 없이 저장, 중복 불허 하는 자료형  set 객체 선언을 이용하여 객체 생성s = set([1,2,3,1,2,3])    # {1, 2, 3}s.remove(1)			      # {2, 3}s.update([1,4,5,6,7])     #{1,2,3,4,5,6,7}s.discard(3)              #{1,2,4,5,6,7}s.clear()  수학에서 활용하는 다양한 집합 연산 가능s1 = set([1,2,3,4,5])s2 = set([3,4,5,6,7])s1.union(s2)	       # {1, 2, 3, 4, 5, 6, 7}s1|s2                  # {1, 2, 3, 4, 5, 6, 7}  / | : ors1.intersection(s2)    # {3, 4, 5}s1&amp;amp;s2                  # {3, 4, 5}s1.difference(s2)      # {1, 2}s1 - s2                # {1, 2}Dictionary      데이터를 저장할 때 구분 지을 수 있는 값을 함께 저장    (ex) 주민등록번호, 제품 모델 번호        구분을 위한 데이터 고유 값을 Identifier 또는 Key 라고 함        Key 값을 활용하여, 데이터 값(Value)를 관리 함  사용  key와 value를 매칭하여 key로 value를 검색  다른 언어에서는 Hash Table이라는 용어를 사용  {Key1:Value1, Key2:Value2, Key3:Value3 …}student_info = {20140012:&#39;Sungchul&#39;, 20131490: &#39;Dahae&#39;, 20159482: &#39;JaeHong&#39;}sudent_info[20140012]student_info[2014003] = &#39;Wonchul&#39;Dictionary Handling&amp;gt;&amp;gt;&amp;gt;country_code={}    # Dict생성&amp;gt;&amp;gt;&amp;gt;country_code={&quot;America&quot;:1,&quot;Korea&quot;:82,&quot;China&quot;:86,&quot;Japan&quot;:81}&amp;gt;&amp;gt;&amp;gt;country_code{&#39;America&#39;:1,&#39;China&#39;:86,&#39;Korea&#39;:82,&#39;Japan&#39;:81}&amp;gt;&amp;gt;&amp;gt;country_code.items()    # Dict데이터출력dict_items([(&#39;America&#39;,1),(&#39;China&#39;,86),(&#39;Korea&#39;,82),(&#39;Japan&#39;,81)])&amp;gt;&amp;gt;&amp;gt;country_code.keys()    # Dict키값만출력dict_keys([&#39;America&#39;,&#39;China&#39;,&#39;Korea&#39;,&#39;Japan&#39;])&amp;gt;&amp;gt;&amp;gt;country_code[&quot;Gernman&quot;]=49    # Dict추가&amp;gt;&amp;gt;&amp;gt;country_code{&#39;America&#39;:1,&#39;Gernman&#39;:49,&#39;China&#39;:86,&#39;Korea&#39;:82,&#39;Japan&#39;:81}&amp;gt;&amp;gt;&amp;gt;country_code.values()    # DictValue만출력dict_values([1,49,86,82,81])&amp;gt;&amp;gt;&amp;gt;fork,vincountry_code.items():...print(&quot;Key : &quot;,k)...print(&quot;Value : &quot;,v)...Key :AmericaValue :1Key :GernmanValue :49Key :ChinaValue :86Key :KoreaValue :82Key :JapanValue :81&amp;gt;&amp;gt;&amp;gt; &quot;Korea&quot; in country_code.keys()    # Key값에 &quot;Korea&quot;가 있는지 확인True&amp;gt;&amp;gt;&amp;gt; 82 in country_code.values()    # Value값에 82가 있는지 확인TrueLab : Command CounterCommand Analyzer      Command : 사용자가 서버에 입력한 명령어    어떤 사용자가 얼마나 많이 명령어를 입력하였을까?  import csvdefgetKey(item):    # 정렬을 위한 함수  returnitem[1]     # 신경쓸 필요 없음command_data=[]     # 파일 읽어오기with open(&quot;command_data.csv&quot;,&quot;r&quot;)as csvfile:  spamreader=csv.reader(csvfile,delimiter=&#39;,&#39;,quotechar=&#39;&quot;&#39;)  for row inspamreader:    command_data.append(row)command_counter={}    # dict생성, 아이디를key값, 입력줄수를value값for data in command_data:    # list 데이터를 dict로 변경  if data[1] in command_counter.keys():    # 아이디가 이미 Key값으로 변경 되었을 때    command_counter[data[1]]+=1    # 기존출현한아이디  else:    command_counter[data[1]]=1     # 처음나온아이디    dictlist=[]    # dict를 list로 변경for key,value in command_counter.items():  temp =[key,value]  dictlist.append(temp)  sorted_dict=sorted(dictlist,key=getKey,reverse=True) # list를 입력 줄 수로 정렬print(sorted_dict[:100])    # List의 상위 10개 값만 출력Collection module 1Collections  List, Tuple, Dict에 대한 python Built-in 확장 자료 구조(모듈)  편의성, 실행 효율 등을 사용자에게 제공함  아래의 모듈이 존재함form collections import dequeform collections import Counterform collections import OrderedDictform collections import namedtupledeque  Stack, Queue를 지원하는 모듈  List에 비해 효율적인 자료 저장 방식을 지원함from collections import dequedequeList = deque()for i in range(5): dequeList.append(i) print(dequeList)dequeList.appendleft(10)print(dequeList)  rotate, reverse 등 Linked List의 특성을 지원  기존 list 형태의 함수를 모두 지원dequeList.rotate(2)print(dequeList)dequeList.rotate(2)print(dequeList)dequeList.extend([5, 6, 7])print(dequeList)print(dequeList)print(deque(reversed(dequeList)))  deque는 기존 list 보다 효율적인 자료구조 제공  효율적 메로리 구조로 처리 속도 향상Collection module 1OrderedDict      Dict와 달리, 데이터를 입력한 순서대로 dict를 반환함        Dict type의 값을 value 또는 key 값으로 정렬할 때 사용 가능  defaultdict  Dict type의 값에 기본 값을 지정, 신규값 생성 시 사용하는 방법from collections import defaultdictd = defaultdict(object)       # Default dictionary를 생성d = defaultdict(lambda: 0)    # Default 값을 0으로 설정pirnt(d[&quot;first&quot;])             # 0 출력  하나의 지문에 각 단어들이 몇 개나 있는지 세고 싶을 경우  text mining 접근법 : Vector Space Model소문자로 만든 후, 띄어쓰기 기준으로 자름from collections import OrderedDictword_count = defaultdict(object)     # Default dictionary를 생성word_count = defaultdict(lambda: 0)  # Default 값을 0으로 설정for word in text:  word_count[word] += 1  for i, v in OrderedDict(scorted(word_cont.items(),                                 key = lambda t: t[1] reverse = True)).items():  print(i, v)    # 참고 : defaultdict 사용한 것과 동일for word in text:  if word in word_count.keys():    word_count[word] += 1  else:    word_count[word] = 0Collection module 3Counter  Sequence type의 data element들의 갯수를 dict 형태로 반환from collections import Counterc = Counter()c = Counter(&#39;gallahad&#39;)print(c)    # Counter({&#39;a&#39;:3, &#39;l&#39;:2, &#39;g&#39;:1, &#39;d&#39;:1, &#39;h&#39;:1}) 출력  Dict type, keyword parameter 등도 모두 처리 가능c = Counter({&#39;red&#39;: 4, &#39;blue&#39;:2})print(c)print(list(c.elements()))# Counter({&#39;red:4, &#39;blue&#39;:2})#[&#39;blue&#39;, &#39;blue&#39;, &#39;red&#39;, &#39;red&#39;, &#39;red&#39;, &#39;red&#39;]c = Counter(cats=4, dogs=8)print(c)print(list(c.elements()))# Counter({&#39;dogs&#39;: 4, &#39;cats&#39;: 4})# [&#39;dogs&#39;,&#39;dogs&#39;,&#39;dogs&#39;,&#39;dogs&#39;,&#39;cats&#39;,&#39;cats&#39;,&#39;cats&#39;,&#39;cats&#39;]  Set의 연산들을 지원함c = Counter(a=4, b=2, c=0, d=-2)d = Counter(a=1, b=2, c=3, d=4)c.subtract(d)  # c - dprint(c) # Counter({&#39;a&#39;:3, &#39;b&#39;:0, &#39;c&#39;:-3, &#39;d&#39;:-6})  word counter의 기능도 손쉽게 제공text = &quot;&quot;&quot;A press release is the quickest and easiest wqy to get free ......&quot;&quot;&quot;.lower().split()print(Counter(text))# Counter({&#39;a&#39;:12, &#39;to&#39;10, &#39;the&#39;:9, ....})print(Counter(text)[&quot;a&quot;])# 12namedtuple  Tuple 형태로 data 구조체를 저장하는 방법  저장되는 data의 variable을 사전에 지정해서 저장from collections import namedtuplePoint = namedtuple(&#39;Point&#39;, [&#39;x&#39;, &#39;y&#39;])p = Point(11, y=22)print(p[0] + p[1])x, y = p    # unpackingprint(x, y)print(p.x + p.y)print(Point(x = 11, y = 22))Chapter 8.  Pythonic Code 1Split &amp;amp; JoinSplitString Type의 값을 나눠서 List 형태로 변환items = &#39;zero one two three&#39;.split()    # 빈칸을 기준으로 문자열 나누기print(item)    # [&#39;zero&#39;, &#39;one&#39;, &#39;two&#39;, &#39;three&#39;]example = &#39;python, jquery, javascript&#39;    # &#39;,&#39; 을 기준으로 문자열 나누기example.split(&quot;,&quot;)    # [&#39;python&#39;, &#39;jquery&#39;, &#39;javascript&#39;]a, b, c = example.split(&quot;,&quot;)     # 리스트에 있는 각 값을 a, b, c 변수로 unpackingexample = &#39;cs50.gachon.edu&#39;subdomain, domain, tld = example.splic(.)    # &#39;.&#39;을 기준으로 문자열 나누기 -&amp;gt; unpackingJoinString List를 합쳐 하나의 String으로 반환할 때 사용colors = [&#39;red&#39;, &#39;blue&#39;, &#39;green&#39;, &#39;yellow&#39;]rusult = &#39;&#39;.join(colors)print(result)    # &#39;redbluegreenyellow&#39;result = &#39; &#39;.joing(colors)    # 연결 시 빈칸 1칸으로 연결print(result)   # red blue green yellowresult = &#39;, &#39;.join(colors)    # 연결 시 &quot;, &quot;으로 연결print(result)    # &#39;red, blue, green, yellow&#39;result = &#39;-&#39;.joing(colors)    # 연결 시 &#39;-&#39;으로 연결print(result)    # &#39;red-blue-green-yellow&#39;List ComprehensionList Comprehension  기존 List 사용하여 간단히 새로운 List를 만드는 기법  포괄적인 List, 포함되는 리스트라는 의미로 사용 됨  파이썬에서 가장 많이 사용되는 기법 중 하나  일반적으로 for + append 보다 속도가 빠름## General Styleresult = []for i in range(10):  result.append(i)print(result)    # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]# List Comprehensions 1result = [i for i in range(10)]print(result)    # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]result = [i for i in range(10) if i % 2 == 0]print(result)    # [0, 2, 4, 6, 8]# List Comprehensions 2word_1 = &quot;Hello&quot;word_2 = &quot;World&quot;result = [i + j for i in word_1 for j in word_2]    # Nested For loop# for i in word_1#   for j in word_2#    [i + j]print(result)# [&#39;HW&#39;, &#39;Ho, &#39;Hr&#39;, &#39;Hl&#39;, &#39;Hd&#39;, &#39;eW&#39;, &#39;eo&#39;, &#39;er&#39;, &#39;el&#39;, &#39;ed&#39;, &#39;lW&#39;, &#39;lo&#39;, &#39;lr&#39;, &#39;ll&#39;, &#39;ld&#39;, &#39;lW&#39;, &#39;lo&#39;, &#39;lr&#39;, &#39;ll&#39;, &#39;ld&#39;, &#39;oW&#39;, &#39;oo&#39;, &#39;or&#39;, &#39;ol&#39;, &#39;od&#39;] # List Comprehensions 3case_1 = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;]case_2 = [&quot;D&quot;, &quot;E&quot;, &quot;A&quot;]result = [i + j for i in case_1 for j in case_2]print(result)[&#39;AD&#39;, &#39;AE&#39;, &#39;AA&#39;, &#39;BD&#39;, &#39;BE&#39;, &#39;BA&#39;, &#39;CD&#39;, &#39;CE&#39;, &#39;CA&#39;]result = [ i + j for i in case_1 for j in case_2 if not(i == j)]# Filter: i와 j과 같다면 List에 추가하지 않음result[&#39;AD&#39;, &#39;AE&#39;, &#39;BD&#39;, &#39;BE&#39;, &#39;BA&#39;, &#39;CD&#39;, &#39;CE&#39;, &#39;CA&#39;]result.sort()print(result)[&#39;AD&#39;, &#39;AE&#39;, &#39;BA&#39;, &#39;BD&#39;, &#39;BE&#39;, &#39;CA&#39;, &#39;CD&#39;, &#39;CE&#39;]words =&#39;The quick brown fox jumps over the lazy dog&#39;.split()# 문장을 빈칸 기준으로 나눠 list로 변환print(words)# [&#39;The&#39;,&#39;quick&#39;,&#39;brown&#39;,&#39;fox&#39;,&#39;jumps&#39;,&#39;over&#39;,&#39;the&#39;,&#39;lazy&#39;,&#39;dog&#39;]stuff = [[w.upper(),w.lower(),len(w)] for w in words]# list의 각 elemente들을 대문자, 소문자, 길이로 변환하여 two dimensional list로 변환for i in stuff :   print(i)  # [&#39;THE&#39;,&#39;the&#39;,3]# [&#39;QUICK&#39;,&#39;quick&#39;,5]# [&#39;BROWN&#39;,&#39;brown&#39;,5]# [&#39;FOX&#39;,&#39;fox&#39;,3]# [&#39;JUMPS&#39;,&#39;jumps&#39;,5]# [&#39;OVER&#39;,&#39;over&#39;,4]# [&#39;THE&#39;,&#39;the&#39;,3]# [&#39;LAZY&#39;,&#39;lazy&#39;,4]# [&#39;DOG&#39;,&#39;dog&#39;,3]Two dimensional &amp;amp; One Dimensionalcase_1 = [&quot;A&quot;,&quot;B&quot;,&quot;C&quot;]case_2 = [&quot;D&quot;,&quot;E&quot;,&quot;A&quot;][&#39;AD&#39;,&#39;AE&#39;,&#39;AA&#39;,&#39;BD&#39;,&#39;BE&#39;,&#39;BA&#39;,&#39;CD&#39;,&#39;CE&#39;,&#39;CA&#39;]result = [i + j for i in case_1 for j in case_2]print(result)result = [[i + j for i in case_1] for j in case_2]print(result)Enumerate &amp;amp; ZipEnumerate  List의 element(sequence type)를 추출할 때 번호(index)를 붙여서 추출for i,v in enumerate([&#39;tic&#39;,&#39;tac&#39;,&#39;toe&#39;]):  # list에 있는 index와 값을 unpacking   print(i,v)  # 0 tic# 1 tac# 2 toemylist = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]list(enumerate(mylist))    # list에 있는 index와 값을 unpacking 하여 list로저장# [(0,&#39;a&#39;),(1,&#39;b&#39;),(2,&#39;c&#39;),(3,&#39;d&#39;)]{i:j for i,j in enumerate(&#39;GachonUniversity is an academic institute located in South Korea.&#39;.split())}# 문장을 list로 만들고 list의 index와 값을 unpacking 하여 dict로 저장# {0:&#39;Gachon&#39;,1:&#39;University&#39;,2:&#39;is&#39;,3:&#39;an&#39;,4:&#39;academic&#39;,5:&#39;institute&#39;,6:&#39;located&#39;,7:&#39;in&#39;,8:&#39;South&#39;,9:&#39;Korea.&#39;}Zip  두 개의 list의 값을 병렬적으로 추출함alist=[&#39;a1&#39;,&#39;a2&#39;,&#39;a3&#39;]blist=[&#39;b1&#39;,&#39;b2&#39;,&#39;b3&#39;]for a,b in zip(alist,blist): # 병렬적으로 값을 추출  print(a,b)  # a1 b1  # a2 b2  # a3 b3  a,b,c = zip((1,2,3),(10,20,30),(100,200,300)) # 각 tuple의 같은 index 끼리 묶음(1,10,100)(2,20,200)(3,30,300)[sum(x) for x in zip((1,2,3), (10,20,30), (100,200,300))]# 각 Tuple 같은 index를 묶어 합을 list로 변환[111,222,333]Enumerate &amp;amp; Zipalist=[&#39;a1&#39;,&#39;a2&#39;,&#39;a3&#39;]blist=[&#39;b1&#39;,&#39;b2&#39;,&#39;b3&#39;]for i,(a,b)in enumerate(zip(alist,blist)):  print(i,a,b) # index alist[index] blist[index] 표시0 a1 b1 1 a2 b22 a3 b3Chapter 9. Pythonic Code 2Map &amp;amp; ReduceLambda  함수 이름 없이, 함수처럼 쓸 수 있는 익명함수  수학의 람다 대수에서 유래  Python3 부터는 권장하지 않으나 여전히 많이 쓰임# General functiondef f(x, y):    return x + yprint(f(1, 4))# Lambda Functionf = lambda x, y: x + yprint(f(1, 4))f = lambda x: x**2print(f(3))f = lambda x: x/2print(f(3))print((lambda x: x + 1)(5))ex = [1, 2, 3, 4, 5]f = lambda x: x**2print(list(map(f, ex)))Map &amp;amp; Reduce      Sequence(ex : list, tuple) 자료형 각 element에 동일한 function을 적용함    ​  즉, f가 ex 각각의 element마다 mapping이 되어서 결과가 출력 된다.ex = [1, 2, 3, 4, 5]ex의 1이 x ** 2에 대입 —&amp;gt; 1 출력ex의 2가 x**2에 대입 —&amp;gt; 4 출력 , ….Map function두 개 이상의 list에도 적용 가능. if filter도 사용 가능ex = [1, 2, 3, 4, 5]f = lambda x, y: x + yprint(list(map(f, ex, ex)))# lambda function에 if filter 적용list(	map(    lambda x: x**2 if x % 2 == 0    else x,		# lambda function에는 반드시 else문 작성해야 함    ex))      Python3는 iteration을 생성하는 식으로 바뀌어서 list를 붙여줘야 list 사용 가능        generator : 실행시점의 값을 생성, 메모리에 효율적  ex = [1, 2, 3, 4, 5]#### list 사용print(list(map(lambda x: x + x, ex)))# 출력 결과 : [2, 4, 6, 8, 10]#### generatorprint((map(lambda x: x + x, ex)))    # 출력 결과 : &amp;lt;map object at 0x10fc5103&amp;gt;# 메모리 주소만 출력 됨. 즉, 생성이 아직 안된 것.#------------------------------------------------f = lambda x: x**2print(map(f, ex))# for문으로 돌리면 생성 됨.  generator의 특성때문. for i in map(f, ex):    print(i)# generator는 메모리 상태에서 대기하고 있다가 실행 시점에서 값을 생성해 줌.    result = map(f, ex)print(result)       # &amp;lt;map object at 0x10fc5103&amp;gt;print(next(result)) # 1Reduce function  map function과 달리 list에 똑같은 함수를 적용해서 통합from functools import reduceprint(reduce(lambda x, y: x + y, [1, 2, 3, 4, 5]))# ((((1 + 2) + 3) + 4) + 5) 순서로 더해져서 값이 구해짐# 출력 결과 : 15Lambda, map, reduce는 간단한 코드로 다양한 기능을 제공한다. 그러나 코드의 직관성이 떨어져서 python3에서는 사용을 권장하지 않는다. Legacy library나 다양한 머신러닝 코드에서 여전히 사용중이긴 하다.Asterisk  흔히 알고 있는 * 를 의미  단순 곱셈, 제곱연산, 가변인자 활용 등 다양하게 사용 된다.*argsdef asterisk_test(a, *args):    print(a, args)    print(type(args))asterisk_test(1, 2, 3, 4, 5, 6)# 출력결과 -----------------------------1 (2, 3, 4, 5, 6)&amp;lt;class &#39;tuple&#39;&amp;gt;**kargsdef asterisk_test(a, **kargs):    print(a, kargs)    print(type(kargs))    asterisk_test(1, b=2, c=3, d=4, e=5, f=6)# 출력 결과 -----------------------------1 {&#39;b&#39;: 2, &#39;c&#39;: 3, &#39;d&#39;: 4, &#39;e&#39;: 5, &#39;f&#39;: 6}&amp;lt;class &#39;dict&#39;&amp;gt;Asterisk : unpacking a container  Tuple, dict 등 자료형에 들어가 있는 값을 unpacking  함수의 입력값, zip 등에 유용하게 사용가능def asterisk_test(a, *args):    print(a, args)    print(type(args))    asterisk_test(1, *(2, 3, 4, 5, 6))# 출력 결과 -----------------------------1 (2, 3, 4, 5, 6)&amp;lt;class &#39;tuple&#39;&amp;gt;# -------------------------------------def asterisk_test(a, args):    print(a, *args)    print(type(args))asterisk_test(1, (2, 3, 4, 5, 6))# 출력 결과 -----------------------------1 2 3 4 5 6&amp;lt;class &#39;tuple&#39;&amp;gt;# -------------------------------------a, b, c = ([1, 2], [3, 4], [5, 6])print(a, b, c)data = ([1, 2], [3, 4], [5, 6])print(*data)# 출력 결과 -----------------------------[1, 2] [3, 4] [5, 6][1, 2] [3, 4] [5, 6]# -------------------------------------def asterisk_test(a, b, c, d):    print(a, b, c, d)data = {&quot;b&quot;:1, &quot;c&quot;:2, &quot;d&quot;:3}asterisk_test(10, **data)# 출력 결과 -----------------------------10 1 2 3# -------------------------------------for data in zip(*([1,2], [3, 4], [5, 6])):    print(data)# 출력 결과 -----------------------------(1, 3, 5)(2, 4, 6)# -------------------------------------Lab : Simple Linear algebra codes  Vector를 파이썬으로 표시하는 다양한 방법 존재vector_a = [1, 2, 10]    # List로 표현vector_b = (1, 2, 10)    # Tuple로 표현vector_c = {&#39;x&#39;: 1, &#39;y&#39;:1, &#39;z&#39;:10}    # dict로 표현print(vector_a, vector_b, vector_c)  최선의 방법은 없음  값의 변경 유무, 속성값 유무에 따라 선택 가능Vector handling with pythonPython은 특유의 간결성이 최대 장점Vector와 같은 수학 연산을 복잡하게 표현한다면 사용 어려움최대한 파이썬만의 특징 살려서 간단하게 연산을 표시Comprehension과 zip 같은 pythonic technique을 적극 활용u = [2, 2]v = [2, 3]z = [3, 5]result = [sum(t) for t in zip(u, v, z)]print(result)# 출력 결과 : [7, 10]Vector의 계산 : Scalar-Vector productu = [1, 2, 3]v = [4, 4, 4]alpha = 2result = [alpha * sum(t) for t in zip(u, v)]print(result)Matrix representation of python  Matrix 역시 python으로 표시하는 다양한 방법 존재mat_a = [[3, 6], [4, 5]]    # Listmat_b = [(3, 6), (4, 5)]    # Tuplemat_c = {(0, 0): 3, (0, 1): 6, (1, 0): 4, (1, 1):5}    # dict  특히 dict로 표현할 때 수 많은 방법이 있음Matrix 계산 : Matrix additionmat_a = [[3, 6], [4, 5]]mat_b = [[5, 8], [6, 7]]result = [[sum(row) for row in zip(*t)]           for t in zip(mat_a, mat_b)]print(result)위 코드에서[t for t in zip(mat_a, mat_b)] 만 출력해보면 [([3, 6], [5, 8]), ([4, 5], [6, 7])] 으로 zip으로 묶어준 것.그 다음 아래 코드에서[[row for row in zip(*t)] for t in zip(mat_a, mat_b)] 를 출력해보면 [[(3, 5), (6, 8)], [(4, 6), (5, 7)]] 로 unpacking된 것을 확인할 수 있다. ( *t에 [([3, 6], [5, 8]), ([4, 5], [6, 7])]이 unpacking 되면서 들어간 것)Matrix 계산 : Scala-Matrix Productmat_a = [[3, 6], [4, 5]]alpha = 4result = [[alpha * element for element in t] for t in mat_a]Matrix 계산 : Matrix Transposemat_a [[1, 2, 3], [4, 5, 6]]result = [[element for element in t] for t in zip(*mat_a)]print(result)    # [[1, 4], [2, 5], [3, 6]][t for t in zip(*mat_a)] 출력해보면 [(1, 4), (2, 5), (3, 6)]Matrix 계산 : Matrix Productmat_a = [[1, 1, 2], [2, 1, 1]]mat_b = [[1, 1], [2, 1], [1, 3]]result = [[sum(a * b for a, b in zip(row_a, column_b))          for column_b in zip(*mat_b)] for row_a in mat_a]print(result)	# [[5, 8], [5, 6] ]두 개 이상의 Argument가 존재할 때는?def vector_addtion(*args):    return [t for t in zip(*args)]vector_addtion([1, 2], [2, 3], [3, 4])"
                        } ,
                     
                        {
                          "title"    : "[Hadoop] Hadoop 완전분산모드 설치",
                          "category" : "",
                          "tags"     : " hadoop, data engineering",
                          "url"      : "/programming/2018/03/01/Hadoop_Setting.html",
                          "date"     : "March 1, 2018",
                          "excerpt"  : "[Progamming] Hadoop 완전분산모드 설치VirtualBox 에 4개의 Ubuntu 를 만든다.설치 시 사용자명은 hadoop 으로 한다.4개를 따로 설치하거나 1개를 만들어서 3개를 복제한다.각각 아래처럼 이름과 IP 주소를 사용할 예정. IP 주소는 각 VirtualBox에서 자동으로 생성되고 뒤에 2자리만 순서대로 변경해서 넣어주면된다.192.168.30.101 hadoop01192.168.30.102 hadoop02192...",
                          "content"  : "[Progamming] Hadoop 완전분산모드 설치VirtualBox 에 4개의 Ubuntu 를 만든다.설치 시 사용자명은 hadoop 으로 한다.4개를 따로 설치하거나 1개를 만들어서 3개를 복제한다.각각 아래처럼 이름과 IP 주소를 사용할 예정. IP 주소는 각 VirtualBox에서 자동으로 생성되고 뒤에 2자리만 순서대로 변경해서 넣어주면된다.192.168.30.101 hadoop01192.168.30.102 hadoop02192.168.30.103 hadoop03192.168.30.104 hadoop04복제 전에 할 일hadoop01에 아래와 같이 먼저 설치한 후 복제해서 hadoop02 ~ hadoop04를 만든다.// vim 설치$ sudo apt-get install vim// 각각 Ubuntu 에 JDK 8 설치$ sudo add-apt-repository ppa:webupd8team/java$ sudo apt-get update$ sudo apt-get install oracle-java8-installer// 자바 환경설정. 아래 내용 입력 후 저장$ vim .bashrcexport JAVA_HOME=/usr/lib/jvm/java-8-oracleVirtualBox 호스트 전용 어댑터 설정1. 전체 설정VirtualBox &amp;gt; 전역 도구(G) &amp;gt; 호스트 네트워크 관리자 &amp;gt; 만들기 &amp;gt; vboxnet0 &amp;gt; 192.168.57.1 &amp;gt; 어댑터 &amp;gt; o 수동으로 어댑터 설정 &amp;gt; IPv4 주소: 192.168.30.1 &amp;gt; IPv4 서브넷 마스크: 255.255.255.02. 각 VM이 종료된 상태에서 어댑터 추가VM &amp;gt; 우클릭 &amp;gt; 설정 &amp;gt; 네트워크 &amp;gt; 어댑터 2 &amp;gt; v 네트워크 어댑터 사용하기 &amp;gt; 다음에 연결됨: 호스트 전용 어댑터 &amp;gt; 이름: vboxnet1 &amp;gt; 확인hadoop 복제 3.  게스트 OS 네트워크 설정// ifconfig 로 체크한 이름 중 enp0s8 을 기준으로 수정하면 됨$ ifconfig // cat 으로 현재 정보 확인$ sudo cat /etc/network/interfaces// hadoop01 에서 vi 로 아래 내용 추가$ sudo vi /etc/network/interfacesauto enp0s8iface enp0s8 inet staticaddress 192.168.56.101netmask 255.255.255.0network 192.168.56.1// hostname 수정$ sudo vi /etc/hostnamehadoop01$ sudo reboot// 리부팅4. 호스트 OS 에서 ping 으로 체크하면 응답 OK$ ping 192.168.56.101// hadoop02 에서 vi 로 아래 내용 추가$ sudo vi /etc/network/interfacesauto enp0s8iface enp0s8 inet staticaddress 192.168.56.102netmask 255.255.255.0network 192.168.56.1// hostname 수정$ sudo vi /etc/hostnamehadoop02// 리부팅$ sudo reboot// hadoop03 에서 vi 로 아래 내용 추가$ sudo vi /etc/network/interfacesauto enp0s8iface enp0s8 inet staticaddress 192.168.56.103netmask 255.255.255.0network 192.168.56.1// hostname 수정$ sudo vi /etc/hostnamehadoop03// 리부팅$ sudo reboot// hadoop04 에서 vi 로 아래 내용 추가$ sudo vi /etc/network/interfacesauto enp0s8iface enp0s8 inet staticaddress 192.168.56.104netmask 255.255.255.0network 192.168.56.1// hostname 수정$ sudo vi /etc/hostnamehadoop04// 리부팅$ sudo vi /etc/hosts127.0.0.1     localhost192.168.56.101  hadoop01192.168.56.102  hadoop02192.168.56.103  hadoop03192.168.56.104  hadoop04hadoop02, hadoop03, hadoop04 에도 모두 같은 내용으로 hosts 파일 수정hadoop01, hadoop02, hadoop03, hadoop04 모두 openssh-server 설치한다.$ sudo apt-get install openssh-server// 아래 부분은 hadoop01 에서만 실행$ ssh-keygen -t rsa # 엔터 3번$ cat ~/.ssh/id_rsa.pub &amp;gt;&amp;gt; ~/.ssh/authorized_keys$ ssh localhost # 처음 한번만 yes, 두번째 접속시 부터는 안 물어봄.$ exit # exit 로 꼭 나와야 함// hadoop02, hadoop03, hadoop04 에 키 복사$ ssh-copy-id -i /home/hadoop/.ssh/id_rsa.pub hadoop@hadoop02$ ssh-copy-id -i /home/hadoop/.ssh/id_rsa.pub hadoop@hadoop03$ ssh-copy-id -i /home/hadoop/.ssh/id_rsa.pub hadoop@hadoop04// 접속 잘 되는지 확인$ ssh hadoop@hadoop02//hadoop 1.2.1 다운로드$ wget https://archive.apache.org/dist/hadoop/common/hadoop-1.2.1/hadoop-1.2.1.tar.gz// 압축 해제$ tar zxvf hadoop-1.2.1.tar.gz$ cd hadoop-1.2.1/$ cd conf$ vi hadoop-env.sh// 맨아래에 내용 추가export JAVA_HOME=/usr/lib/jvm/java-8-oracleexport HADOOP_HOME=/home/hadoop/hadoop-1.2.1export HADOOP_HOME_WARN_SUPPRESS=&quot;TRUE&quot;export HADOOP_HEAPSIZE=1024     // 메모리 설정export HADOOP_PID_DIR=/home/hadoop/hadoop-1.2.1/pids$ vi core-site.xml&amp;lt;?xml version=&quot;1.0&quot;?&amp;gt;&amp;lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;configuration.xsl&quot;?&amp;gt;&amp;lt;!-- Put site-specific property overrides in this file. --&amp;gt;&amp;lt;configuration&amp;gt;    &amp;lt;property&amp;gt;        &amp;lt;name&amp;gt;fs.default.name&amp;lt;/name&amp;gt;        &amp;lt;value&amp;gt;hdfs://hadoop01:9000&amp;lt;/value&amp;gt;    &amp;lt;/property&amp;gt;    &amp;lt;property&amp;gt;        &amp;lt;name&amp;gt;hadoop.tmp.dir&amp;lt;/name&amp;gt;        &amp;lt;value&amp;gt;/home/hadoop/hadoop-data&amp;lt;/value&amp;gt;    &amp;lt;/property&amp;gt;&amp;lt;/configuration&amp;gt;$ vi hdfs-site.xml// dfs.replication : 복제갯수 &amp;lt;?xml version=&quot;1.0&quot;?&amp;gt;&amp;lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;configuration.xsl&quot;?&amp;gt;&amp;lt;!-- Put site-specific property overrides in this file. --&amp;gt;&amp;lt;configuration&amp;gt;    &amp;lt;property&amp;gt;        &amp;lt;name&amp;gt;dfs.replication&amp;lt;/name&amp;gt;        &amp;lt;value&amp;gt;3&amp;lt;/value&amp;gt;        &amp;lt;/property&amp;gt;    &amp;lt;property&amp;gt;        &amp;lt;name&amp;gt;dfs.http.address&amp;lt;/name&amp;gt;        &amp;lt;value&amp;gt;hadoop01:50070&amp;lt;/value&amp;gt;    &amp;lt;/property&amp;gt;        &amp;lt;property&amp;gt;        &amp;lt;name&amp;gt;dfs.secondary.http.address&amp;lt;/name&amp;gt;        &amp;lt;value&amp;gt;hadoop02:50090&amp;lt;/value&amp;gt;    &amp;lt;/property&amp;gt;&amp;lt;/configuration&amp;gt;// 맵리듀스 설정$ vi mapred-site.xml&amp;lt;?xml version=&quot;1.0&quot;?&amp;gt;&amp;lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;configuration.xsl&quot;?&amp;gt;&amp;lt;!-- Put site-specific property overrides in this file. --&amp;gt;&amp;lt;configuration&amp;gt;    &amp;lt;property&amp;gt;        &amp;lt;name&amp;gt;mapred.job.tracker&amp;lt;/name&amp;gt;        &amp;lt;value&amp;gt;hadoop01:9001&amp;lt;/value&amp;gt;    &amp;lt;/property&amp;gt;&amp;lt;/configuration&amp;gt;$ cd hadoop-1.2.1/conf$ ls// secondary namenode: hadoop02// slaves : datanode. hadoop02, hadoop03, hadoop04$ vi masters hadoop02$ vi slaveshadoop02hadoop03hadoop04// 맨 상위로 이동$ cd ~// hadoop-1.2.1 통째로 압축$ tar zcvf hadoop.tar.gz hadoop-1.2.1 // hadoop02, hadoop03, hadoop04로 복사$ scp hadoop.tar.gz hadoop@hadoop02:/home/hadoop$ scp hadoop.tar.gz hadoop@hadoop03:/home/hadoop$ scp hadoop.tar.gz hadoop@hadoop04:/home/hadoop// 압축풀기$ ssh hadoop@hadoop02$ tar zxvf hadoop.tar.gz$ exit$ ssh hadoop@hadoop03$ tar zxvf hadoop.tar.gz$ exit$ ssh hadoop@hadoop04$ tar zxvf hadoop.tar.gz$ exit// 하둡 경로 설정 $ vim .bashrcexport HADOOP_INSTALL=/home/hadoop/hadoop-1.2.1exprot PATH=$PATH:$HADOOP_INSTALL/bin$ exit// 리부트$ sudo reboot// hadoop 실행$ hadoop// 반드시 hadoop01 에서 실행$ hadoop namenode -format$ start-all.sh$ jpsJobTrackerJpsNameNode // 3가지 떠있는 것 확인 가능// 나머지 hadoop2,3,4에서도 동일 명령어로 확인 가능// hadoop01, hadoop02, hadoop03, hadoop04 에서 jps 실행해서 확인// hadoop01은 NameNode, JobTracker// hadoop02은 SecondaryNameNode, DataNode, TaskTracker// hadoop03은 DataNode, TaskTracker// hadoop04은 DataNode, TaskTracker 가 보이면 OK// 반드시 종료 시켜야 함$ stop-all.sh 브라우저로 http://hadoop01:50070 으로 접속해서 HDFS 확인브라우저로  http://hadoop01:50030 으로 접속해서 MapReduce 확인"
                        } ,
                     
                        {
                          "title"    : "[Algorithms] BFS(Breadth-First Search 너비우선탐색)",
                          "category" : "",
                          "tags"     : " algorithms",
                          "url"      : "/algorithms/2018/03/01/BFS.html",
                          "date"     : "March 1, 2018",
                          "excerpt"  : "[Algorithms] BFS : Breadth-First Search 너비우선탐색Graph Algorithmsshortest-path problem(최단경로 문제)을 해결할 때 사용한다.순서  문제를 그래프로 모형화  너비 우선탐색으로 문제 해결그래프연결 집합을 모형화한 것을 그래프라고 한다.node와 edge로 이루어져 있다.출처 : http://mathworld.wolfram.com/GraphEdge.html너비우선탐색개념그래프 전체...",
                          "content"  : "[Algorithms] BFS : Breadth-First Search 너비우선탐색Graph Algorithmsshortest-path problem(최단경로 문제)을 해결할 때 사용한다.순서  문제를 그래프로 모형화  너비 우선탐색으로 문제 해결그래프연결 집합을 모형화한 것을 그래프라고 한다.node와 edge로 이루어져 있다.출처 : http://mathworld.wolfram.com/GraphEdge.html너비우선탐색개념그래프 전체를 탐색하는 방법 중 하나이다. 너비우선탐색, 깊이우선탐색이 있다.Facebook에서 연결되는 사람(촌) 중에 과자 회사에 다니고 있는 사람이 있는지 찾으려고 한다고 가정해보자.A는 시작점인 ‘나’자신이고, B, C, D는 1촌, E, F, G, H는 2촌, I, J, K는 3촌이 된다. K가 과자 회사에 다닌다고 가정한다면 목표는 K가 된다.      시작점 A(나)에서 목표 K(과자회사에 다니는 사람)까지 도달하는 것을 기준으로 탐색을 한다.        시작점 A에서 갈 수 있는 후보를 확인한다. 이때 후보 탐색은 먼저 나와 닿아 있는 1촌에서 탐색해야 한다. 후보 : B, C, D        하나의 정점을 선택하는데, 이때 선택 기준은 후보 중 가장 먼저 추가된 것이다.    B, C, D 처럼 동일 시점에 생긴 경우 아무거나 선택해도 된다.    후보 정점은 FIFO(선입선출) 구조, 즉, Queue 데이터 구조이다.        이제 1촌인 B로 이동하여 B의 1촌 중에  살펴본다. 즉, 후보가 될 수 있는 정점을 탐색한다.  후보 : E        마찬가지로 C로 이동하여 C에서 후보가 될 수 있는 점정를 탐색한다.  후보 : F, G        D로 이동하여 D에서 후보가 될 수 있는 정점을 탐색한다.  후보 : H        E, F, G, H가 있는 부분을 위와 같은 방법으로 탐색한다.    탐색은 목표인 K에 도달하거나 모든 탐색이 완료될 때까지 반복한다.    ​    탐색 순서를 정리해 보면 아래와 같다.A -&amp;gt; B, C, DB -&amp;gt; EC -&amp;gt; F, GD -&amp;gt; HE -&amp;gt; IFGH -&amp;gt; J, KIJK (목표 도달)구현하기관계를 표현하는 자료구조 Hash table로 그래프를 구현하고, Queue를 이용하여 알고리즘을 구현한다.그래프 구현하기graph = {}    # hash table 생성graph[&quot;A&quot;] = [&#39;B&#39;, &#39;C&#39;, &#39;D&#39;]    # Key값 A에 Value로 B, C, D 넣음. 즉, A의 1촌 B, C, D가 조회된다.graph[&quot;B&quot;] = [&quot;E&quot;]graph[&quot;C&quot;] = [&quot;F&quot;, &quot;G&quot;]graph[&quot;D&quot;] = [&quot;H&quot;]graph[&quot;E&quot;] = [&quot;I&quot;]graph[&quot;F&quot;] = []graph[&quot;G&quot;] = []graph[&quot;H&quot;] = [&quot;J&quot;, &quot;K&quot;]graph[&quot;I&quot;] = []graph[&quot;J&quot;] = []graph[&quot;K&quot;] = []알고리즘 구현하기순서  비어 있는 queue를 준비  확인할 명단을 queue에 넣는다.  queue에서 한사람씩 꺼내서 과자회사에 다니는 사람이 맞는지 확인한다.  맞으면 탐색 종료  과자회사에 다니는 사람이 없으면 이웃을 queue에 추가다시 위 그래프로 생각해보면,비어있는 queue srch = deque() 에 graph[&#39;A&#39;] = [&#39;B&#39;, &#39;C&#39;, &#39;D&#39;] 가 들어간다. srch = graph[&#39;A&#39;]&#39;B&#39;부터 한 사람씩 꺼내서 &#39;pop(&#39;B&#39;)&#39;, &#39;B&#39;==&#39;과자회사 다니는 사람&#39; 이 맞는지 확인한다.맞느면 탐색을 종료하고, 아니면 &#39;B&#39;의 이웃&#39;E&#39;를 que에 추가한다.&#39;C&#39;,&#39;D&#39;도 마찬가지 방법으로 탐색한다.deque(double-ended queue)Queue + Pop이 합쳐진 개념이다. 양쪽이 열려 있기 때문에, 양방향으로 push, pop이 가능하다.즉, 크기가 가변적이다. 하지만 중간에 데이터를 삽입, 삭제하기 어렵다. Python작성중....JAVA// Java program to print BFS traversal from a given source vertex.// BFS(int s) traverses vertices reachable from s.import java.io.*;import java.util.*; // This class represents a directed graph using adjacency list// representationclass Graph{    private int V;   // No. of vertices    private LinkedList&amp;lt;Integer&amp;gt; adj[]; //Adjacency Lists     // Constructor    Graph(int v)    {        V = v;        adj = new LinkedList[v];        for (int i=0; i&amp;lt;v; ++i)            adj[i] = new LinkedList();    }     // Function to add an edge into the graph    void addEdge(int v,int w)    {        adj[v].add(w);    }     // prints BFS traversal from a given source s    void BFS(int s)    {        // Mark all the vertices as not visited(By default        // set as false)        boolean visited[] = new boolean[V];         // Create a queue for BFS        LinkedList&amp;lt;Integer&amp;gt; queue = new LinkedList&amp;lt;Integer&amp;gt;();         // Mark the current node as visited and enqueue it        visited[s]=true;        queue.add(s);         while (queue.size() != 0)        {            // Dequeue a vertex from queue and print it            s = queue.poll();            System.out.print(s+&quot; &quot;);             // Get all adjacent vertices of the dequeued vertex s            // If a adjacent has not been visited, then mark it            // visited and enqueue it            Iterator&amp;lt;Integer&amp;gt; i = adj[s].listIterator();            while (i.hasNext())            {                int n = i.next();                if (!visited[n])                {                    visited[n] = true;                    queue.add(n);                }            }        }    }     // Driver method to    public static void main(String args[])    {        Graph g = new Graph(4);         g.addEdge(0, 1);        g.addEdge(0, 2);        g.addEdge(1, 2);        g.addEdge(2, 0);        g.addEdge(2, 3);        g.addEdge(3, 3);         System.out.println(&quot;Following is Breadth First Traversal &quot;+                           &quot;(starting from vertex 2)&quot;);         g.BFS(2);    }}// This code is contributed by Aakash Hasija참고문헌[1] https://ko.khanacademy.org/computing/computer-science/algorithms/breadth-first-search/a/breadth-first-search-and-its-uses[2] https://en.wikipedia.org/wiki/Breadth-first_search[3] http://jpython.blogspot.kr/2012/12/bfs-algorithm-in-python.html[4] https://www.geeksforgeeks.org/breadth-first-traversal-for-a-graph/"
                        } ,
                     
                        {
                          "title"    : "[Algorithms] 9. Palindrome Number",
                          "category" : "",
                          "tags"     : " alorithms",
                          "url"      : "/algorithms/2018/02/28/LeetCode_9.html",
                          "date"     : "February 28, 2018",
                          "excerpt"  : "[LeetCode] 9. Palindrome Number  Determine whether an integer is a palindrome. Do this without extra space.  주어진 정수가 회문인지 판단하라. 공백은 고려하지 않는다.Approch1. Palindrome회문이란 앞에서 부터 읽을 때와 뒤에서 부터 읽을 때가 같은 문장을 말한다(ex) LEVEL, 12321, 다시합창합시다,여기서는 공백은 고려하지 않는다....",
                          "content"  : "[LeetCode] 9. Palindrome Number  Determine whether an integer is a palindrome. Do this without extra space.  주어진 정수가 회문인지 판단하라. 공백은 고려하지 않는다.Approch1. Palindrome회문이란 앞에서 부터 읽을 때와 뒤에서 부터 읽을 때가 같은 문장을 말한다(ex) LEVEL, 12321, 다시합창합시다,여기서는 공백은 고려하지 않는다.2. Idea숫자가 주어질 때 맨 앞과 맨 뒤부터 순차적으로 비교하면 회문인지 알 수 있다.3. Solution음수인지 아닌지 판단하고, 음수가 아니면 x를 뒤에서 부터 읽은 값과 x가 동일한지 판단한다.class Solution:    def isPalindrome(self, x):        if x &amp;lt; 0 :            False        elif x[::-1] == x:            return True        else:            return False"
                        } ,
                     
                        {
                          "title"    : "[Hadoop] HDFS Architecture",
                          "category" : "",
                          "tags"     : " hadoop, data engineering",
                          "url"      : "/programming/2018/02/27/HDFS-Architecture.html",
                          "date"     : "February 27, 2018",
                          "excerpt"  : "[Programming] HDFS Architecture  파일 저장, 읽기 : 어플리케이션에서 클라이언트로 파일 저장 또는 읽기 요청  Client : application 요청에 의해 client가 NameNode에 데이터 블록의 위치를 조회  NameNode에게 받은 Data block 위치를 통해 Client가 데이터를 직접 조회  Heart beat : DataNode가 상태를 주기적으로 보고(일종의 출석체크).      Seco...",
                          "content"  : "[Programming] HDFS Architecture  파일 저장, 읽기 : 어플리케이션에서 클라이언트로 파일 저장 또는 읽기 요청  Client : application 요청에 의해 client가 NameNode에 데이터 블록의 위치를 조회  NameNode에게 받은 Data block 위치를 통해 Client가 데이터를 직접 조회  Heart beat : DataNode가 상태를 주기적으로 보고(일종의 출석체크).      Secondary NameNode    NameNode가 망가지면 데이터가 어디에 저장되어 있는지 알 수 없기때문에 읽어들일 수 없으므로, NameNode를 백업해 두었다가 NameNode가 망가지면 다시 복구해 주는 역할    ​        HDFS와 MapReduce는 둘다 Master/Slave 구조    HDFS          Master : Name node(메타정보관리)      Slave : Data node(실제 데이터)        MapReduce                  Master : JobTracker(TaskTracker의 상태 및 전체 작업의 진행 상황등을 지속적으로 감시하며 일 시적인 장애에 대해 자동 복구 기능 제공)                    Slave : TaskTracker                    Map Task        레코드 단위로 처리해야 하는 작업을 담당                    Reduce Task        관련된 데이터 끼리 묶어서 처리해야 하는 작업 담당              MapReduce만 코딩. 나머지는 자동.    Node : 컴퓨터 한 대라고 생각하면 됨.  Name Node, Data Node : HDFS 컨트롤  Job tracker, task tracker : MapReduce 컨트롤"
                        } ,
                     
                        {
                          "title"    : "[Hadoop] Hadoop 설치 및 WordCount 예제 실습",
                          "category" : "",
                          "tags"     : " hadoop, data engineering",
                          "url"      : "/programming/2018/02/24/Hadoop_wordCount_example.html",
                          "date"     : "February 24, 2018",
                          "excerpt"  : "HadoopHadoop = HDFS + MapReduceMode 3가지HDFS 설치방식  Stand alone (독립실행모드) : 기본 실행모드. 분산저장 안함. 코딩은 가능.  Pseudo-distributed (가상분산모드) : 하나의 컴퓨터에 설치  Fully distributed (완전분산모드) : 여러 대의 컴퓨터에 설치순서  VirtualBox 설치  Ubuntu 14.04.2 설치 // 이후에는 VirtualBox 내의 Ubu...",
                          "content"  : "HadoopHadoop = HDFS + MapReduceMode 3가지HDFS 설치방식  Stand alone (독립실행모드) : 기본 실행모드. 분산저장 안함. 코딩은 가능.  Pseudo-distributed (가상분산모드) : 하나의 컴퓨터에 설치  Fully distributed (완전분산모드) : 여러 대의 컴퓨터에 설치순서  VirtualBox 설치  Ubuntu 14.04.2 설치 // 이후에는 VirtualBox 내의 Ubuntu 에서 진행  JDK 설치  하둡 다운로드  하둡 Stand-alone 모드 구성  하둡 가상 분산 모드 구성  이클립스 다운로드, 설정  WordCount 예제 코딩  테스트Ubuntu에 JDK 8 설치$ sudo add-apt-repository ppa:webupd8team/java$ sudo apt-get update$ sudo apt-get install oracle-java8-installer하둡 다운로드 후 압축 해제URL : https://archive.apache.org/dist/hadoop/common/hadoop-1.2.1/hadoop-1.2.1.tar.gz 에서 다운로드아래 명령어로 압축해제 및 설정.참고 : 앞으로 나오는 /home/유저명/ 에서 “유저명” 부분은 “여러분 자신의 유저명”으로 수정하여 입력하면 된다.vim 설정$ vi .vimrc# 아래 내용 입력 후 저장filetype plugin onsyntax onset numberset pasteset rulerset laststatus=2$ cat .vimrc     # 확인$ cd Downloads$ cp hadoop-1.2.1.tar.gz ~       # ~ : home folder$ cd ~$ tar zxvf hadoop-1.2.1.tar.gz$ sudo apt-get install vim$ vim .bashrc # 맨 끝에 아래 3줄 추가export JAVA_HOME=/usr/lib/jvm/java-8-oracleexport HADOOP_INSTALL=/home/유저명/hadoop-1.2.1export PATH=PATH:HADOOP_INSTALL/bin$ source .bashrc # 변경 내용 적용$ hadoop # 메시지가 정상 출력되면 OK하둡 Stand-alone 모드 구성 및 예제 테스트아래 명령어로 테스트.폴더명 중복 안되게 해야 한다.$ cd /home/유저명/hadoop-1.2.1$ mkdir input$ cp README.txt input$ hadoop jar hadoop-examples-1.2.1.jar wordcount input output# cat output/part-r-00000 # 결과 확인      jar : 파일을 실행하는 명령어        hadoop-examples-1.2.1.jar 파일이 하둡 예제파일        $ hadoop jar hadoop-examples-1.2.1.jar wordcount input output : hadoop / 파일실행 / 파일명 / 할일 /입력폴더 / 출력폴더    # 출력 결과18/02/24 14:10:18 INFO util.NativeCodeLoader: Loaded the native-hadoop library18/02/24 14:10:18 INFO input.FileInputFormat: Total input paths to process : 118/02/24 14:10:18 WARN snappy.LoadSnappy: Snappy native library not loaded18/02/24 14:10:18 INFO mapred.JobClient: Running job: job_local1707454656_000118/02/24 14:10:19 INFO mapred.LocalJobRunner: Waiting for map tasks18/02/24 14:10:19 INFO mapred.LocalJobRunner: Starting task: attempt_local1707454656_0001_m_000000_018/02/24 14:10:19 INFO util.ProcessTree: setsid exited with exit code 018/02/24 14:10:19 INFO mapred.Task:  Using ResourceCalculatorPlugin : org.apache.hadoop.util.LinuxResourceCalculatorPlugin@415eb82d18/02/24 14:10:19 INFO mapred.MapTask: Processing split: file:/home/jane/hadoop-1.2.1/input:0+136618/02/24 14:10:19 INFO mapred.MapTask: io.sort.mb = 10018/02/24 14:10:19 INFO mapred.MapTask: data buffer = 79691776/9961472018/02/24 14:10:19 INFO mapred.MapTask: record buffer = 262144/32768018/02/24 14:10:19 INFO mapred.MapTask: Starting flush of map output18/02/24 14:10:19 INFO mapred.MapTask: Finished spill 018/02/24 14:10:19 INFO mapred.Task: Task:attempt_local1707454656_0001_m_000000_0 is done. And is in the process of commiting18/02/24 14:10:19 INFO mapred.LocalJobRunner: 18/02/24 14:10:19 INFO mapred.Task: Task &#39;attempt_local1707454656_0001_m_000000_0&#39; done.18/02/24 14:10:19 INFO mapred.LocalJobRunner: Finishing task: attempt_local1707454656_0001_m_000000_018/02/24 14:10:19 INFO mapred.LocalJobRunner: Map task executor complete.18/02/24 14:10:19 INFO mapred.Task:  Using ResourceCalculatorPlugin : org.apache.hadoop.util.LinuxResourceCalculatorPlugin@2f01765518/02/24 14:10:19 INFO mapred.LocalJobRunner: 18/02/24 14:10:19 INFO mapred.Merger: Merging 1 sorted segments18/02/24 14:10:19 INFO mapred.Merger: Down to the last merge-pass, with 1 segments left of total size: 1832 bytes18/02/24 14:10:19 INFO mapred.LocalJobRunner: 18/02/24 14:10:19 INFO mapred.Task: Task:attempt_local1707454656_0001_r_000000_0 is done. And is in the process of commiting18/02/24 14:10:19 INFO mapred.LocalJobRunner: 18/02/24 14:10:19 INFO mapred.Task: Task attempt_local1707454656_0001_r_000000_0 is allowed to commit now18/02/24 14:10:19 INFO output.FileOutputCommitter: Saved output of task &#39;attempt_local1707454656_0001_r_000000_0&#39; to output18/02/24 14:10:19 INFO mapred.LocalJobRunner: reduce &amp;gt; reduce18/02/24 14:10:19 INFO mapred.Task: Task &#39;attempt_local1707454656_0001_r_000000_0&#39; done.18/02/24 14:10:19 INFO mapred.JobClient:  map 100% reduce 100%18/02/24 14:10:19 INFO mapred.JobClient: Job complete: job_local1707454656_000118/02/24 14:10:19 INFO mapred.JobClient: Counters: 2018/02/24 14:10:19 INFO mapred.JobClient:   Map-Reduce Framework18/02/24 14:10:19 INFO mapred.JobClient:     Spilled Records=26218/02/24 14:10:19 INFO mapred.JobClient:     Map output materialized bytes=183618/02/24 14:10:19 INFO mapred.JobClient:     Reduce input records=13118/02/24 14:10:19 INFO mapred.JobClient:     Virtual memory (bytes) snapshot=018/02/24 14:10:19 INFO mapred.JobClient:     Map input records=3118/02/24 14:10:19 INFO mapred.JobClient:     SPLIT_RAW_BYTES=9918/02/24 14:10:19 INFO mapred.JobClient:     Map output bytes=205518/02/24 14:10:19 INFO mapred.JobClient:     Reduce shuffle bytes=018/02/24 14:10:19 INFO mapred.JobClient:     Physical memory (bytes) snapshot=018/02/24 14:10:19 INFO mapred.JobClient:     Reduce input groups=13118/02/24 14:10:19 INFO mapred.JobClient:     Combine output records=13118/02/24 14:10:19 INFO mapred.JobClient:     Reduce output records=13118/02/24 14:10:19 INFO mapred.JobClient:     Map output records=17918/02/24 14:10:19 INFO mapred.JobClient:     Combine input records=17918/02/24 14:10:19 INFO mapred.JobClient:     CPU time spent (ms)=018/02/24 14:10:19 INFO mapred.JobClient:     Total committed heap usage (bytes)=35756441618/02/24 14:10:19 INFO mapred.JobClient:   File Input Format Counters 18/02/24 14:10:19 INFO mapred.JobClient:     Bytes Read=136618/02/24 14:10:19 INFO mapred.JobClient:   FileSystemCounters18/02/24 14:10:19 INFO mapred.JobClient:     FILE_BYTES_WRITTEN=39571418/02/24 14:10:19 INFO mapred.JobClient:     FILE_BYTES_READ=29033018/02/24 14:10:19 INFO mapred.JobClient:   File Output Format Counters 18/02/24 14:10:19 INFO mapred.JobClient:     Bytes Written=1326        ​  하둡 가상분산 모드 구성5개의 프로세스 : Name node, Secondary Namenode, Data node, Job tracker, Tast tracker아래 순서로 네개 파일 수정해 준다.      hadoop-env.sh : 환경변수 설정        core-site.xml : HDFS와 MapReduce에서 공통적으로 사용할 환경정보 설정        hdfs-site.xml : HDFS에서 사용할 환경정보 설정        mapred-site.xml : MapReduce에서 사용할 환경정보 설정  hadoop-env.sh 수정JAVA_HOME 파라미터를 실제 JDK가 설치된 경로로 수정하는 작업$ vim /home/유저명/hadoop-1.2.1/conf/hadoop-env.sh # 맨 끝에 3줄 추가export JAVA_HOME=/usr/lib/jvm/java-8-oracleexport HADOOP_HOME=/home/유저명/hadoop-1.2.1export HADOOP_HOME_WARN_SUPPRESS=&quot;TRUE&quot;  # Warning: $HADOOP_HOME is deprecated.보안 인증 관련 명령 실행# 컴퓨터끼리 연결해서 접속할 수 있게 ssh 설정$ sudo apt-get install openssh-server$ sudo /etc/init.d/ssh restart # ssh 재실행$ netstat -ntl # 0:::22 있으면 OK# 접속할 때마다 비밀번호 묻지 않게 public key 공유(리눅스의 기능)$ ssh-keygen -t rsa # 엔터 3번$ cat ~/.ssh/id_rsa.pub &amp;gt;&amp;gt; ~/.ssh/authorized_keys$ ssh localhost # 처음 한번만 yes, 두번째 접속시 부터는 안 물어봄.$ exit # exit 로 꼭 나와야 함core-site.xml (하둡의 핵심 설정 파일) 편집$ vim /home/유저명/hadoop-1.2.1/conf/core-site.xml&amp;lt;?xml version=&quot;1.0&quot;?&amp;gt;&amp;lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;configuration.xsl&quot;?&amp;gt;&amp;lt;!-- Put site-specific property overrides in this file. --&amp;gt;&amp;lt;configuration&amp;gt;    &amp;lt;property&amp;gt;        &amp;lt;name&amp;gt;fs.default.name&amp;lt;/name&amp;gt;        &amp;lt;value&amp;gt;hdfs://localhost:9000&amp;lt;/value&amp;gt;    &amp;lt;/property&amp;gt;    &amp;lt;property&amp;gt;        &amp;lt;name&amp;gt;hadoop.tmp.dir&amp;lt;/name&amp;gt;        &amp;lt;value&amp;gt;/home/유저명/hadoop-1.2.1/hadoop-${user.name}&amp;lt;/value&amp;gt;    &amp;lt;/property&amp;gt;&amp;lt;/configuration&amp;gt;  fs.default.name : HDFS의 기본 이름을 의미. URI 형태로 사용.  hadoop.tmp.dir : 하둡에서 발생하는 임시 데이터를 저장하기 위한 공간hdfs-site.xml (하둡 분산 파일 관련 설정) 편집$ vim /home/유저명/hadoop-1.2.1/conf/hdfs-site.xml&amp;lt;?xml version=&quot;1.0&quot;?&amp;gt;&amp;lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;configuration.xsl&quot;?&amp;gt;&amp;lt;!-- Put site-specific property overrides in this file. --&amp;gt;&amp;lt;configuration&amp;gt;    &amp;lt;property&amp;gt;        &amp;lt;name&amp;gt;dfs.name.dir&amp;lt;/name&amp;gt;        &amp;lt;value&amp;gt;/home/유저명/hadoop-1.2.1/dfs/name&amp;lt;/value&amp;gt;    &amp;lt;/property&amp;gt;    &amp;lt;property&amp;gt;        &amp;lt;name&amp;gt;dfs.name.edits.dir&amp;lt;/name&amp;gt;        &amp;lt;value&amp;gt;${dfs.name.dir}&amp;lt;/value&amp;gt;    &amp;lt;/property&amp;gt;    &amp;lt;property&amp;gt;        &amp;lt;name&amp;gt;dfs.data.dir&amp;lt;/name&amp;gt;        &amp;lt;value&amp;gt;/home/유저명/hadoop-1.2.1/dfs/data&amp;lt;/value&amp;gt;    &amp;lt;/property&amp;gt;&amp;lt;/configuration&amp;gt;      dfs.replication : HDFS의 저장될 데이터의 복제본 갯수를 의미. 가상분산모드 : 1 완전분산모드 : 3    dfs.http.address : 네임노드용 웹서버의 주소값.  기본값 : 0.0.0.0:50070  dfs.secondary.http.address : 보조네임노드용 웹서버 주소값.  기본값 : 0.0.0.0:50090mapred-site.xml (하둡 맵리듀스 관련 설정) 편집$ vim /home/유저명/hadoop-1.2.1/conf/mapred-site.xml&amp;lt;?xml version=&quot;1.0&quot;?&amp;gt;&amp;lt;?xml-stylesheet type=&quot;text/xsl&quot; href=&quot;configuration.xsl&quot;?&amp;gt;&amp;lt;!-- Put site-specific property overrides in this file. --&amp;gt;&amp;lt;configuration&amp;gt;    &amp;lt;property&amp;gt;        &amp;lt;name&amp;gt;mapred.job.tracker&amp;lt;/name&amp;gt;        &amp;lt;value&amp;gt;localhost:9001&amp;lt;/value&amp;gt;    &amp;lt;/property&amp;gt;    &amp;lt;property&amp;gt;        &amp;lt;name&amp;gt;mapred.local.dir&amp;lt;/name&amp;gt;        &amp;lt;value&amp;gt;${hadoop.tmp.dir}/mapred/local&amp;lt;/value&amp;gt;    &amp;lt;/property&amp;gt;    &amp;lt;property&amp;gt;        &amp;lt;name&amp;gt;mapred.system.dir&amp;lt;/name&amp;gt;        &amp;lt;value&amp;gt;${hadoop.tmp.dir}/mapred/system&amp;lt;/value&amp;gt;    &amp;lt;/property&amp;gt;&amp;lt;/configuration&amp;gt;  mapred.job.tracker : JobTracker 데몬의 주소를 의미. 데이터 노드에서 이 주소로 맵리듀스 작업을 요청.namenode 포맷 ( namenode 는 처음에 꼭 한번 만 포맷해야 한다.)$ hadoop namenode -format하둡 시작 및 확인$ cd /home/유저명/hadoop-1.2.1$ bin/start-all.sh하둡 프로세스 확인$ jps # 5개의 프로세스 출력되면 OK : namenode, secondarynamenode, datanode, jobtracker, tasktracker# 브라우저에서 접속해서 확인URL : http://localhost:50070/dfshealth.jsp   // HDFS 확인URL : http://localhost:50030/jobtracker.jsp // MapReduce 확인이클립스 다운로드, 설정이클립스 다운로드URL : http://www.eclipse.org/downloads/ 로 접속Eclipse IDE for Java Developers 를 다운로드압축해제$ cd Downloads$ tar zxvf eclipse-java-luna-SR2-linux-gtk-x86_64.tar.gz이클립스를 사용하여 Maven 프로젝트 생성Maven에 대한 이해https://www.slideshare.net/sunnykwak90/ss-43767933이클립스 실행파일 (탐색기)를 이용해서 eclipse 폴더의 eclipse 파일을 더블 클릭해서 실행Maven Project 생성File -&amp;gt; New -&amp;gt; Project -&amp;gt; Maven -&amp;gt; Maven Project 선택-&amp;gt; [Next] -&amp;gt; [Next] -&amp;gt; [Next] -&amp;gt;Group Id : kr.co.mycompant.hdArtifact Id : wcount-&amp;gt; [Finish]pom.xml 수정해서 하둡 jar 파일 설정pom.xml 을 열어서  와  사이에 아래 내용을 입력의미 : 하둡 1.2.1 관련된 jar 파일들을 자동으로 다운로드해서 환경 설정&amp;lt;dependency&amp;gt;  &amp;lt;groupId&amp;gt;org.apache.hadoop&amp;lt;/groupId&amp;gt;  &amp;lt;artifactId&amp;gt;hadoop-core&amp;lt;/artifactId&amp;gt;  &amp;lt;version&amp;gt;1.2.1&amp;lt;/version&amp;gt;&amp;lt;/dependency&amp;gt;WordCount 예제 코딩WordCount 클래스 생성sr/main/java 밑의 kr.co.mycompany.hd.wcount 에서우클릭해서 -&amp;gt; New -&amp;gt; Class : WordCount -&amp;gt; [Finish]아래 소스를 입력package kr.co.mycompany.hd.wcount;import java.io.IOException;import java.util.StringTokenizer;import org.apache.hadoop.conf.Configuration;import org.apache.hadoop.fs.Path;import org.apache.hadoop.io.LongWritable;import org.apache.hadoop.io.Text;import org.apache.hadoop.mapreduce.Job;import org.apache.hadoop.mapreduce.Mapper;import org.apache.hadoop.mapreduce.Reducer;import org.apache.hadoop.mapreduce.lib.input.FileInputFormat;import org.apache.hadoop.mapreduce.lib.input.TextInputFormat;import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;import org.apache.hadoop.mapreduce.lib.output.TextOutputFormat;public class WordCount {  public static class MyMapper    extends Mapper&amp;lt;LongWritable, Text, Text, LongWritable&amp;gt; {    private final static LongWritable one = new LongWritable(1);    private Text word = new Text();    @Override    public void map(LongWritable key, Text value, Context context)        throws IOException, InterruptedException {      String line = value.toString();      StringTokenizer tokenizer =        new StringTokenizer(line, &quot;\t\r\n\f|,.()&amp;lt;&amp;gt; &quot;);      while(tokenizer.hasMoreTokens()) {        word.set(tokenizer.nextToken().toLowerCase());        context.write(word, one);      }    }// map  }// MyMapper  public static class MyReducer    extends Reducer&amp;lt;Text, LongWritable, Text, LongWritable&amp;gt; {    private LongWritable sumWritable = new LongWritable();    @Override    protected void reduce(Text key, Iterable&amp;lt;LongWritable&amp;gt; values,        Context context)        throws IOException, InterruptedException {      long sum = 0;      for(LongWritable val : values) {        sum += val.get();      }      sumWritable.set(sum);      context.write(key, sumWritable);    }// reduce  }// MyReducer  public static void main(String[] args) throws Exception {    Configuration conf = new Configuration();    Job job = new Job(conf, &quot;WordCount&quot;);    job.setJarByClass(WordCount.class);    job.setMapperClass(MyMapper.class);    job.setReducerClass(MyReducer.class);    job.setOutputKeyClass(Text.class);    job.setOutputValueClass(LongWritable.class);    job.setInputFormatClass(TextInputFormat.class);    job.setOutputFormatClass(TextOutputFormat.class);    FileInputFormat.addInputPath(job, new Path(args[0]));    FileOutputFormat.setOutputPath(job, new Path(args[1]));    job.waitForCompletion(true);  }// main}// end코드 설명package kr.co.mycompany.hd.wcount;public class WordCount {  public static class MyMapper    extends Mapper&amp;lt;LongWritable, Text, Text, LongWritable&amp;gt; {    // Mapper를 상속받음 &amp;lt;KEYIN, VALUEIN, KEYOUT, VALUEOUT&amp;gt;        private final static LongWritable one = new LongWritable(1);    // final로 정의(상수). 공유하기 위해 static. 1을 담음. 어떤 단어가 한 번 나올 때 1이 들어가는 용도        private Text word = new Text();    // 단어 담는 용도. 이 위치에서 생성하는 게 성능 향상에 도움이 됨.     // Map에 생성되면 갯수만큼 호출되므로 매번 객체생성. Map에서는 객체 생성 안함. Map 들어가기 전에 생성.        @Override      public void map(LongWritable key, Text value, Context context)    // Text value : 텍스트가 한 줄씩 들어옴    // Context : 나와 하둡의 연결고리            throws IOException, InterruptedException {      String line = value.toString();      // String으로 바꿔야 자바에서 자료 관리가 가능하므로 변경      // toStirng : String으로 바꿔줌            StringTokenizer tokenizer = new StringTokenizer(line, &quot;\t\r\n\f|,.()&amp;lt;&amp;gt; &quot;);      // StringTokenizer&amp;lt;String, 구분자&amp;gt;, 구분자 맨 뒤에 공백 있음.      // Dear Bear River            while(tokenizer.hasMoreTokens()) {        word.set(tokenizer.nextToken().toLowerCase());        context.write(word, one);      // hasMoreTokens() : 반복문 돌면서 &#39;hello hadoop world&#39;      // -&amp;gt; 3개로 끊어짐. &#39;hello&#39;, &#39;hadoo&#39;, &#39;world&#39;                // word.set : 하나씩 담음      // nextToken : 다음 토큰 가져옴      // toLowerCase : 대소문자 구분 안하기 위해 모두 소문자로 변경            // context.write(word, one) : 단어 기록. (ex) &#39;hello&#39;가 1번 나왔다 : (&#39;hello&#39;, 1)          // 첫번째 루프 : Deer, 1 / 두번째 루프 : Bear, 1 / 세번째 루프 : River 1      }    }// map  }// MyMapper      // Reducer  public static class MyReducer    extends Reducer&amp;lt;Text, LongWritable, Text, LongWritable&amp;gt; {    // Reducer &amp;lt;KEYIN, VALUEIN, KEYOUT, VALUEOUT&amp;gt;            private LongWritable sumWritable = new LongWritable();        @Override    protected void reduce(Text key, Iterable&amp;lt;LongWritable&amp;gt; values,        Context context)    // Iterable : 반복자                throws IOException, InterruptedException {      long sum = 0;      for(LongWritable val : values) {        sum += val.get();      }      // 반복문 돌면서 LongWritable로 하나씩 가져온다.      // 배열로 두개가 들어온다고 생각(그림의 Shuffling 부분 참고). (ex) Bear[1, 1]            sumWritable.set(sum);      // 더해 줌              context.write(key, sumWritable);           }// reduce  }// MyReducer       // Main method  public static void main(String[] args) throws Exception {    Configuration conf = new Configuration();    // Configuration : 환경설정       Job job = new Job(conf, &quot;WordCount&quot;);    // Job : MapReduce의 Job    job.setJarByClass(WordCount.class);    job.setMapperClass(MyMapper.class);    job.setReducerClass(MyReducer.class);    job.setOutputKeyClass(Text.class);    job.setOutputValueClass(LongWritable.class);    job.setInputFormatClass(TextInputFormat.class);    job.setOutputFormatClass(TextOutputFormat.class);    FileInputFormat.addInputPath(job, new Path(args[0]));  // 입력폴더    FileOutputFormat.setOutputPath(job, new Path(args[1]));  // 출력폴더    job.waitForCompletion(true);  }}// end예제를 Maven Install 로 ~.jar 파일로 패키징한다.프로젝트 우클릭 -&amp;gt; Run As -&amp;gt; 8 Maven installtarget 폴더에 wcount-0.0.1-SNAPSHOT.jar 이 생성된다.하둡 가상 분산 모드에서 생성된 jar 을 사용하여 WordCount 실행, 테스트  wcount-0.0.1-SNAPSHOT.jar 파일을 /home/유저명/hadoop-1.2.1 폴더에 복사한다.  hadoop fs 명령을 사용하여 테스트할 파일을 복사한다.$ hadoop fs -put READEME.txt .hadoop jar 명령을 사용하여 예제를 실행/테스트한다.$ hadoop jar wcount-0.0.1-SNAPSHOT.jar kr.co.mycompany.hd.wcount.WordCount README.txt output1결과가 output1 폴더에 part-r-00000 이라는 파일로 저장된다.hadoop fs -cat 명령어를 통해서 학인 할 수 있다.$ hadoop fs -cat output1/part-r-00000wc : wordcount 명령어단어수 31,  줄 179, 크기 1366[참고문헌]https://blog.naver.com/sungback/220381870733https://www.slideshare.net/sunnykwak90/ss-43767933http://naver.me/IDMfcGl3https://hadoop.apache.org/docs/stable/hadoop-mapreduce-client/hadoop-mapreduce-client-core/MapReduceTutorial.html"
                        } ,
                     
                        {
                          "title"    : "[Algorithms] 7. Reverse Integer",
                          "category" : "",
                          "tags"     : " algorithms",
                          "url"      : "/algorithms/2018/02/21/Leetcode_7_Reverse_Integer.html",
                          "date"     : "February 21, 2018",
                          "excerpt"  : "[LeetCode] 7. Reverse Integerhttps://leetcode.com/problems/two-sum/description/  Given a 32-bit signed integer, reverse digits of an integer.  주어진 32비트의 부호있는 정수의 자릿 수를 뒤집는 문제.  Example 1:  Input: 123Output:  321    Example 2:  Input: -123Output: -...",
                          "content"  : "[LeetCode] 7. Reverse Integerhttps://leetcode.com/problems/two-sum/description/  Given a 32-bit signed integer, reverse digits of an integer.  주어진 32비트의 부호있는 정수의 자릿 수를 뒤집는 문제.  Example 1:  Input: 123Output:  321    Example 2:  Input: -123Output: -321    Example 3:  Input: 120Output: 21    Note:Assume we are dealing with an environment which could only hold integers within the 32-bit signed integer range. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.  32비트의 부호 있는 정수의 범위 안에서만 정수를 저장할 수 있다고 가정한다. 반전된 정수가 오버플로우되면 함수가  0을 반환한다고 가정한다.Approach1. The flow of thought문제를 보고 처음 든 생각은 조건을 어떻게 처리할 것인가이다.조건은 총 2가지인데, 32비트 범위라는 것과 부호가 있다는 것이다. 둘다 따로 처리하는 게 편할 것 같아서 각각 따로 처리하는 조건문을 만들었다. (J가 부호를 따로 처리하라고 힌트를 줌)1) 입력값 x의 부호가 양수인지, 음수인지 판단 sign = 1 if (x&amp;lt;0): sign = -1 2) 자릿수 뒤집는 연산 시행 int(str(sign(x)*x)[::-1] 3) 32비트 내의 정수인지 판단 r &amp;gt; 2**31 -1 2. Solutiondef reverse(x):    sign = 1    if (x &amp;lt; 0):        sign = -1    r = int(str(sign*x)[::-1])    return (sign*r, 0)[r &amp;gt; 2**31 - 1]3. Another solutionpython 솔루션 중 Vote를 가장 많이 받은 코드이다.def reverse(x):    s = cmp(x, 0)    r = int(`s*x`[::-1])    return s*r * (r &amp;lt; 2**31)"
                        } ,
                     
                        {
                          "title"    : "[R] R의 Data Structure",
                          "category" : "",
                          "tags"     : " CNN, Deep Learning, speech recognition, signal processing",
                          "url"      : "/statistics/2018/02/19/Rprogramming.html",
                          "date"     : "February 19, 2018",
                          "excerpt"  : "[R] R의 Data structure데이터 구조 종류      Scalar : element가 1개인 vector이다.    # scalar 만들기a &amp;lt;- &#39;a&#39;alphabet &amp;lt;- &#39;abcdefg&#39;num &amp;lt;- 1        ​        Vector : 같은 종류의 element가 여러개 들어 있는 1차원 matrix이다.    # vector 만들기table &am...",
                          "content"  : "[R] R의 Data structure데이터 구조 종류      Scalar : element가 1개인 vector이다.    # scalar 만들기a &amp;lt;- &#39;a&#39;alphabet &amp;lt;- &#39;abcdefg&#39;num &amp;lt;- 1        ​        Vector : 같은 종류의 element가 여러개 들어 있는 1차원 matrix이다.    # vector 만들기table &amp;lt;- c(&#39;a&#39;, &#39;b&#39;)table &amp;lt;- c(1, 2, 3, 5)bool &amp;lt;- c(TRUE, FALSE)        ​        Matrix : 2차원으로 된 배열. 일반적이 표 데이터를 생각하면 된다.    # matrix 만들기# 2 by 3 행렬 생성&amp;gt; mat &amp;lt;- matrix(c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;), nrow = 2, ncol = 3)&amp;gt; mat    [,1] [,2] [,3][1,] &quot;a&quot;  &quot;c&quot;  &quot;e&quot; [2,] &quot;b&quot;  &quot;d&quot;  &quot;f&quot;         ​        Array : 차원이  matrix 보다 많다. Matrix는 2차원(행, 열)인데 비해 배열은 그 이상 차원이 형성될 수 있다.    # array 만들기&amp;gt; animal &amp;lt;- c(&quot;dog&quot;, &quot;cat&quot;, &quot;rabbit&quot;)&amp;gt; feed &amp;lt;- c(&quot;meat&quot;, &quot;fish&quot;, &quot;carrot&quot;)&amp;gt; jump &amp;lt;- c(&quot;3&quot;, &quot;2&quot;, &quot;1&quot;)&amp;gt; arr &amp;lt;- array(data = c(animal, feed, jump), dim = c(1,3,3), dimnames = list(&#39;value&#39;, c(1, 2, 3), c(&#39;animal&#39;,&#39;feed&#39;,&#39;jump&#39;)))# array(c(vector1, vector2, vector3), dim = c(1,3,3), dimnames = list(row.names, column.names, matrix.names))&amp;gt; arr, , animal      1     2     3       value &quot;dog&quot; &quot;cat&quot; &quot;rabbit&quot;, , feed      1      2      3       value &quot;meat&quot; &quot;fish&quot; &quot;carrot&quot;, , jump      1   2   3  value &quot;3&quot; &quot;2&quot; &quot;1&quot;                 Data Frame : matrix와 유사한데, 유형이 다른 데이터를 함께 넣을 수 있다.    &amp;gt; animal &amp;lt;- c(&quot;dog&quot;, &quot;cat&quot;, &quot;rabbit&quot;)&amp;gt; feed &amp;lt;- c(&quot;meat&quot;, &quot;fish&quot;, &quot;carrot&quot;)&amp;gt; jump &amp;lt;- c(&quot;3&quot;, &quot;2&quot;, &quot;1&quot;)&amp;gt; dat &amp;lt;- data.frame(animal, feed, jump)&amp;gt; dat  animal   feed jump1    dog   meat    32    cat   fish    23 rabbit carrot    1        ​        List :서열화된 성분들의 집합체이다. 예시를 보는 게 빠르다.    &amp;gt; title &amp;lt;- &quot;Phone Book&quot;&amp;gt; name &amp;lt;- c(&quot;Tom&quot;, &quot;Jack&quot;, &quot;Jean&quot;, &quot;Mike&quot;)&amp;gt; phone &amp;lt;- c(&quot;010-1234-1234&quot;, &quot;010-2345-5678&quot;, &quot;010-9876-5673&quot;)&amp;gt; index &amp;lt;- c(1, 2, 3)&amp;gt; etc &amp;lt;- matrix(1:10, nrow=2)&amp;gt; mylist &amp;lt;-list(title = title, info = name, phone, index, etc)&amp;gt; mylist$title[1] &quot;Phone Book&quot;$info[1] &quot;Tom&quot;  &quot;Jack&quot; &quot;Jean&quot; &quot;Mike&quot;[[3]][1] &quot;010-1234-1234&quot; &quot;010-2345-5678&quot; &quot;010-9876-5673&quot;[[4]][1] 1 2 3[[5]]     [,1] [,2] [,3] [,4] [,5][1,]    1    3    5    7    9[2,]    2    4    6    8   10&amp;gt; mylist$title[1] &quot;Phone Book&quot;&amp;gt; mylist[[3]][1] &quot;010-1234-1234&quot; &quot;010-2345-5678&quot; &quot;010-9876-5673&quot;&amp;gt; mylist$info[1][1] &quot;Tom&quot;        ​  "
                        } ,
                     
                        {
                          "title"    : "[Algorithms] 1. Two Sum",
                          "category" : "",
                          "tags"     : " leetcode, algorithm",
                          "url"      : "/2018/02/14/Leetcode_1_Two_Sum.html",
                          "date"     : "February 14, 2018",
                          "excerpt"  : "https://leetcode.com/problems/two-sum/description/  Given an array of integers, return indices of the two numbers such that they add up to a specific target.  You may assume that each input would have exactly one solution, and you may not use the ...",
                          "content"  : "https://leetcode.com/problems/two-sum/description/  Given an array of integers, return indices of the two numbers such that they add up to a specific target.  You may assume that each input would have exactly one solution, and you may not use the same element twice.  주어진 정수 배열을 이용하여, 임의의 두 수 합계가 타겟(target) 값이 되는 두 숫자의 인덱스를 반환해라.  각 입력에는 정확히 하나의 솔루션이 있다고 가정 할 수 있으며, 동일한 원소를 두 번 사용할 수 없다.Example:Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1].Approach1. Brute ForceCS를 전공한 친구에게 문제를 처음 접근할 때 가장 나이브한 방법으로 해 보라는 조언을 들어서 일단 brute force로 접근해보았다. index 0부터 순차적으로 더해서 target과 비교해보는 방법이다.  nums[0]+nums[1]==target  해서 같으면 True로 두 index를 반환하고, 다르면 False이므로   nums[0]+nums[2]==target  처럼 다음 index와 더한다. 1.1 Complexity Analysis위 알고리즘을 짜 보면 for문이 두개 생성되어서 시간 복잡도가  이 된다. 각각의 for문의 시간복잡도는  이다.1.2 문제 쪼개기1) i 에 nums의 길이만큼 숫자 대입 i in len(nums)-1 2) 기준 숫자와 순차적으로 대입되는 숫자 더하기  nums[i] + nums[j], j는 1부터 len(nums)  3) 더한 숫자와 타겟 비교 nums[i] + nums[j] == target 4) True일 경우 인덱스 출력 5) False일 경우 비교대상 숫자 하나 증가 1.3 Solutionnums = [2, 11, 14, 7, 15]target = 9class Solution:    def twoSum(self, nums, target):        for i in range(len(nums)):            for j in range(i + 1, len(nums)):                if (nums[i] + nums[j]) == target:                    return i, j                test = Solution()i, j = test.twoSum(nums,target)print(i, j)1.4 문제점시간복잡도가 초과했다는 결과가 나온다. 다른 방법을 찾아보니까 Hash를 이용한 방법이 있다.2. HashTwo-pass Hash Table, One-pass Hash Table이 있다. 둘다 Solutions에 나온대로 따라해보고 익혔다.2.1 Two-pass Hash Table  (발번역이므로 참고만…)  시간복잡도를 개선하기 위해서, 배열에 보수가 존재하는지 확인하기 위한 효율적인 방법이 필요하다. 보수가 존재하는 경우 해당 index를 탐색할 필요가 있다. Index에 배열의 각 element의 mapping을 유지하기 위한 가장 좋은 방법은 hash table 이다.  속도를 위해 space를 trade함으로써 O(n)에서 O(1)으로 탐색 시간을 감소 시킨다. 해시 테이블은 정확히 이 목적에 맞게 구축되었으며, 거의 일정한 시간의 빠른 탐색을 지원한다. “거의”라고 말한 이유는 충돌이 발행사면 탐색은 O(n) 시간으로 나빠질 수 있다. 하지만 hash 함수가 주의깊에 선택되기만 한다면 hash table의 탐색은  O(1)로 분할된다.  심플한 구현은 두개의 반복문이 사용된다. 첫번째 반복문에는,  테이블에 각 요소의 값과 인덱스를 추가한다. 그 다음, 두 번째 반복에서 각 요소의 보수 (target - nums[i])가 테이블에 있는지 확인한다. 보수는 nums[i]가 아니어야한다.solution처음에 어려워서 stack overflow에 질문했는데 아래와 같은 답변을 받았다.(stackoverflow 없었으면 CS 공부는 포기했을듯;;)  stack overflow 질문에 달린 답변 :  Complement refers to the other number that when added to the current number will give you the value of the target.  If (for all) a + b = target, then a’s complement is b.  In order to see if a complement of a number is there, instead of looping through the array (which is O(n)), they are storing it (the elements in the source array) is a hash map.2.1.1 Solution참고하여 Discuss에 있는 코드를 공부해보았다.class Solution(object):    def twoSum(self, nums, target):        if len(nums) &amp;lt;= 1:            return False        buff_dict = {}        for i in range(len(nums)):            if nums[i] in buff_dict:                return [buff_dict[nums[i]], i]            else:                buff_dict[target - nums[i]] = i      nums, target을 인수로 받는 함수를 정의한다.        nums의 길이가 1이거나 그보다 작으면 계산할 수 없으므로 False를 반환한다.        buff_dict={}  : buff_dict 라는 빈 딕셔너리(해시)를 생성한다.        for i in range(len(nums)): : nums의 길이만큼 for문이 loop된다.        if nums[i] in buff_dict: return [buff_dict[nums[i]], i] : nums[i]가 buff_dict 안에 있는 값이면 buff_dict[nums[i]]와 i 를 반환한다.        else: buff_dict[target - nums[i]] = i :    nums[i]가 buff_dict 안에 없는 값이면 buff_dict[target - nums[i]] = i 를 반환한다.  2.1.3 Examplenums = [2, 11, 7, 5]target = 9buff_dict = {}for i in range(len(nums)):    if nums[i] in buff_dict:        return [buff_dict[nums[i]], i]    else:        buff_dict[target - nums[i]] = i1) i = 0nums[0] = 2 —&amp;gt; buff_dict 에 key 존재 안함 —&amp;gt; buff_dict[9 - 2] = buff_dict[7] = 0buff_dict 이라는 딕셔너리에 key:7, value:0 이 들어가게 된다. 즉, buff_dict= {7:0} 2) i = 1nums[1] = 11 —&amp;gt; buff_dict에 key 존재 안함 —&amp;gt; buff_dict[9 - 11] = buff_dict[-2] = 1buff_dict = {7:0, -2:1}3) i = 2nums[2] = 7 —&amp;gt; buff_dict에 key = 7 존재 —&amp;gt; buff_dict[7], 2 를 반환 —&amp;gt; return(0, 2)확인해보면, nums[0] = 2, nums[2] = 7 이므로 더하면 target 값 9와 같다."
                        } 
                     ,
                     
                       {
                         
                            "title"    : "[Project] (작성 중...) 딥러닝 CNN 모델을 이용한 고양이 자두의 통조림 요청 울음소리인식",
                            "category" : "",
                            "tags"     : " CNN, Deep Learning, speech recognition, signal processing",
                            "url"      : "/portfolio/2017-10-30-project-cnn",
                            "date"     : "October 30, 2017",
                            "excerpt"  : "",
                            "content"  : "목차  서론1.1 문제해결의 배경 및 목적1.2. 문제해결의 과정 및 구성  본론2.1 데이터 수집, 전처리 및 적용이론 고찰2.2 MFCC 알고리즘 및 CNN 적용  결론 및 향후 과제참고문헌1. 서론1.1 문제 해결의 배경 및 목적 필자는 죽어가던 새끼 고양이를 아파트 단지에서 우연히 구조 후, 치료해주다가 입양까지 하게 되었다. 오전에는 거의 필자의 어머니와 고양이가 단 둘이 지내게 되었다. 개만 20년을 키운 어머니는 고양이의 습성..."
                         
                       } 
                     
                    
                  ],
            searchResultTemplate: '<div class="search-title"><a href="{url}"><h3> {title}</h3></a><div class="meta">{date} <div class="right"><i class="fa fa-tag"></i> {tags}</div></div><p>{excerpt}</p></div><hr> ',
            noResultsText: 'No results found',
            limit: 10,
            fuzzy: false,
            exclude: []
        })
    </script>
</section>
</section>
    
    
  <!-- Tag list for portfolio -->
  
  


<footer>
  <div class="tag-list"></div>
</footer>

    
</article>

    </div>
    
<footer class="site-footer">
    <p class="text"><a href="https://github.com/lovesignal">Signal</a>
</p>
            <div class="footer-icons">
                <ul>
                <!-- Social icons from Font Awesome, if enabled -->
                
<li>
	<a href="http://localhost:4000/feed.xml" title="Follow RSS feed">
		<span class="fa-stack fa-lg">
            <i class="fa fa-circle fa-stack-2x"></i>
            <i class="fa fa-rss fa-stack-1x fa-inverse"></i>
        </span>
	</a>
</li>



<li>
	<a href="mailto:hmtb.signal@gmail.com" title="Email">
		<span class="fa-stack fa-lg">
            <i class="fa fa-circle fa-stack-2x"></i>
            <i class="fa fa-envelope fa-stack-1x fa-inverse"></i>
        </span>
	</a>
</li>













<li>
	<a href="https://github.com/lovesignal" title="Follow on GitHub">
		<span class="fa-stack fa-lg">
            <i class="fa fa-circle fa-stack-2x"></i>
            <i class="fa fa-github fa-stack-1x fa-inverse"></i>
        </span>
	</a>
</li>
































                </ul>
            </div>
</footer>




  </body>
</html>
